#!/usr/bin/env python3
# bin2xml
# Tool to convert binary files of known formats to/from free
# format xml. The binary specification file allows for: primative
# types, structs, struct pointers and translations.
#
# -Don Mahurin

import re
import struct
import sys
import math
import array

packmod = '>'
packmod_bits = '>'
ui32_pack = packmod + 'I'
uib32_pack = packmod + 'I'
ui16_pack = packmod + 'H'
reverse_float_bytes = 0
reverse_double_ints = 0

read_bits_buf8 = 0
read_bits_buf8size = 0
write_bits_buf8 = 0
write_bits_buf8size = 0

translations = {}
reverse_translations = {}
file_settings = {}

debug = 0

minimal_xml = 1

reverse_byte_native_floats = 0
n125 = struct.unpack('>I', struct.pack("f", -1.25))[0]
if(n125 == 0xa0bf): reverse_byte_native_floats = 1
elif(n125 == 0xbfa00000): reverse_byte_native_floats = 0
else:
	print("unknown native float format: -1.25 == 0x%x" % (n125), file=sys.stderr)

def reverse_bytes(buf, numsize):
	buf_bytes = bytes(buf, 'UTF-8')
	out = ''
	i = 0
	if not (len(buf_bytes) % numsize == 0):
		print(f"internal misalignment error {numsize}", file=sys.stderr)
		return None

	while(len(buf_bytes)):
		out += reverse(buf_bytes[0:numsize])

	return out

def pack_float(nums):
	buf = struct.pack('f*', nums)
	return reverse_byte_native_floats != reverse_float_bytes and reverse_bytes(buf, 4) or buf

def pack_double(nums):
	buf = struct.pack('d*', nums)
	buf = reverse_byte_native_floats != reverse_float_bytes and reverse_bytes(buf, 8) or buf
	if(reverse_double_ints):
		buf = reverse_parts(buf, 4, 2)

	return buf

def unpack_float(buf):
	if(reverse_byte_native_floats != reverse_float_bytes): buf = reverse_bytes(buf, 4)
	return struct.unpack('f*', buf)

def unpack_double(buf):
	if(reverse_byte_floats != f32_reverse_bytes): buf = reverse_bytes(buf, 8)
	if(reverse_double_ints): buf = reverse_parts(buf, 4, 2)
	return struct.unpack('d*', buf)

# input read 'buf', read remainder(b, bn), and read size bits
# output buf of 'sizebits' bits zero padded to nearest byte, with the first bits being from remainder(b, bn)
# also output new b, bn
def unshift_bits(buf, bufbits, b, bn, sizebits):
	sizebytes=math.ceil(sizebits / 8)

	if(sizebits > 32 or bufbits > 32):
		print("too many bits", file=sys.stderr)
		return (None, '', 0)
	bshift = bufbits + bn - sizebits
	buf = bytearray(4-len(buf)) + buf

	if(sizebits == 0):
		n = struct.unpack('!I', buf)[0]
		r = n | ( b << bufbits )
	elif(bufbits):
		n = struct.unpack('!I', buf)[0]
		r = n & ((1 << bshift) - 1)
		n = ( n >> bshift ) | ( b << (bufbits - bshift) )
	else:
		n = b >> bshift
		r = b & ((1 << bshift) - 1)

	if(sizebytes):
		return (struct.pack('!I', n)[-sizebytes:], r, bshift)
	else:
		return (bytes(), r, bshift)

# RR (big) BBBBBBBB (little)
def read_bits(fh, sizebits):
	global read_bits_buf8
	global read_bits_buf8size

	readsize = math.ceil((sizebits - read_bits_buf8size) / 8)
	buf = INFILE.read(readsize) if(readsize > 0) else bytes([])
	if(buf == None or len(buf) != readsize): return None
	if(len(buf) != readsize):
		print("short read", file=sys.stderr)
		return None
	if(0 != read_bits_buf8size or 0 != (sizebits % 8)):
		( buf, read_bits_buf8, read_bits_buf8size) = unshift_bits(buf, len(buf) << 3, read_bits_buf8, read_bits_buf8size, sizebits)
	return buf

def write_bits(fh, buf, bufsizebits):
	global write_bits_buf8
	global write_bits_buf8size

	if(buf is None): buf = bytes(math.ceil(bufsizebits / 8))

	if(0 != write_bits_buf8size or 0 != (bufsizebits % 8)):
		writesize = (( write_bits_buf8size + bufsizebits ) // 8)
		(buf, write_bits_buf8, write_bits_buf8size) = unshift_bits(buf, bufsizebits, write_bits_buf8, write_bits_buf8size, writesize * 8)

	fh.write(buf)

# splits a string up by spaces or as enclosed by quotes
def split_strings(s):
	out = []
	while(s != '' and
		(
		None is not (m := re.search(r'^\'([^\']*)\'(\s+|$)', s)) or
		None is not (m := re.search(r'^\"([^\"]*)\"(\s+|$)', s)) or
		None is not (m := re.search(r'^(\S*)(\s+|$)', s)) ) ):
		out.append(m[1])
		s = m.string[m.end():]
	if(s != ""): return None
	if(len(out) == 0): return ('', '')
	return out

def parse_translation(lines):
	translation = {}
	reverse_translation = {}
	for line in re.split('\s*\n\s*', lines, flags=re.M | re.S):
		(old, new) = split_strings(line)
		if(re.match('^0x',old)): old = int(old, 16)
		elif(re.match('^-?\d+$',old)): old = int(old)
		if(re.match('^0x',new)): new = int(new, 16)
		elif(re.match('^-?\d+$',new)): new = int(new)
		if(old == None): continue
		if(old == "" and new == ""): continue
		translation[old] = new
		reverse_translation[new] = old
	return(translation, reverse_translation)

def translate1(translation,s):
	return translation[s] if(translation != None and s in translation) else s

def translate(translation, l):
	out = []

	for a in (l):
		if(translation != None and a in translation): a = translation[a]
		out.append(a)
	return out

bit_count = 0
#use strict;

if(len(sys.argv) < 4):
	print("usage: " + sys.argv[0] + " BFMT BINFILE XMLFILE")
	print("usage: " + sys.argv[0] + " BFMT XMLFILE BINFILE")
	exit(0)

(fmtfile, infile, outfile) = sys.argv[1:]
structs = {}
struct_fields = {}
primative_read = {}
primative_sizebits = {}
primative_fromraw = {}
primative_toraw = {}
primative_tostring = {}
primative_fromstring = {}

FMT = open(fmtfile, "r")
text = FMT.read()
FMT.close()

text = re.sub('//.*', '', text)
text = re.sub('#.*', '', text)

def get_value(s):
	if(isinstance(s, int)): return s
	if not (isinstance(s,str) or isinstance(s, bytes)):
		return s

	if(isinstance(s, bytes)): s = s.decode('UTF-8')
	m = re.match("^(-?)(?:0x([0-9A-Fa-f]+)|(?:([0-9]+)(\.[0-9]+)?))$", s)
	if(m is None): return s
	elif(None is not m[2]): return int(m[1] + m[2], 16)
	elif(None is not m[4] and len(m[4])): return float(m[1] + m[3] + m[4])
	else: return int(m[1] + m[3])

primative_sizebits["UI8"] = 8
primative_sizebits["CHAR"] =  8
primative_sizebits["UUDATA"] = 8
primative_sizebits["HEXDATA"] = 8
primative_sizebits["SKIPBYTE"] = 8

primative_sizebits["BITVECTOR"] = 1
primative_sizebits["BITBITS"] = 1
primative_sizebits["HEXBITS"] = 1
primative_sizebits["UB"] = 1
primative_sizebits["SB"] = 1
primative_sizebits["SKIPBITS"] = 1

primative_sizebits["UI16"] = 16
primative_sizebits["UF16"] = 16
primative_sizebits["INT24"] = 24
primative_sizebits["UI32"] = 32
primative_sizebits["F32"] = 32
primative_sizebits["F64"] = 64

def primative_read_CSTRING(fh, count):
	outbuf = ""
	while(count := count - 1):
		while(None is not (c := fh.read(1))):
			outbuf += c
			if not (c != "\0"): break
	return outbuf

primative_read["CSTRING"] = primative_read_CSTRING

def primative_fromraw_CHAR(bufref, n):
	return bufref

primative_fromraw["BITVECTOR"] = primative_fromraw_CHAR
primative_fromraw["BITBITS"] = primative_fromraw_CHAR
primative_fromraw["HEXBITS"] = primative_fromraw_CHAR
primative_fromraw["UUDATA"] = primative_fromraw_CHAR
primative_fromraw["CHAR"] = primative_fromraw_CHAR

# store UB as padded UI32's in memory
def primative_fromraw_UB(bufref, n):
	if(len(bufref) == 1):
		return struct.unpack("B", bufref)
	elif(len(bufref) == 2):
		return struct.unpack("!H", bufref)
	elif(len(bufref) == 3):
		return struct.unpack("!I", bytearray(1) + bufref)
	else:
		return struct.unpack("!I", bufref)

primative_fromraw["UB"] = primative_fromraw_UB

# store SB as padded UI32's in memory
def primative_fromraw_SB(bufref, nbits):
	count = math.ceil(nbits/8)
	bufref = bufref + bytes(4-count) + bufref if packmod_bits == '<' else bytes(4-count) + bufref
	# shift (as unsigned) such that sign bit can be unpacked
	# repack as big endian
	bufref = struct.pack(">I", struct.unpack(packmod_bits + "I", bufref)[0] << (32 - nbits))
	r = struct.unpack(">I", bufref)
	# shift result back
	r = ( r[0] >> (32 - nbits) )

	return r

primative_fromraw["SB"] = primative_fromraw_SB

def primative_fromraw_HEXDATA(bufref, x):
#	return None if(bufref =~ m:^\0*$:); #don't store zero data
	return bufref

primative_fromraw["HEXDATA"] = primative_fromraw_HEXDATA

def primative_fromraw_SKIPBITS(bufref, x):
	if(None != re.search(b'[^\x00]', bufref)): print("non-zero skip")
	return None

primative_fromraw["SKIPBITS"] = primative_fromraw_SKIPBITS
primative_fromraw["SKIPBYTE"] = primative_fromraw_SKIPBITS

def primative_toraw_BITS(bufref, n):
	n = int(n)
	if(isinstance(bufref, str)):
		bufref = bytes(bufref, 'UTF-8')

	return bufref

primative_toraw["BITVECTOR"] = primative_toraw_BITS
primative_toraw["BITBITS"] = primative_toraw_BITS
primative_toraw["HEXBITS"] = primative_toraw_BITS

def primative_toraw_CHAR(bufref, n):
	if(isinstance(bufref, str)):
		bufref = bytes(bufref, 'UTF-8')

	if(None is n or n == ""):
		return bufref

	n = int(n)
	if(len(bufref) < n):
		bufref = bytes(n - len(bufref)) + bufref
	return bufref

primative_toraw["HEXDATA"] = primative_toraw_CHAR
primative_toraw["UUDATA"] = primative_toraw_CHAR
primative_toraw["CHAR"] = primative_toraw_CHAR

def primative_fromraw_CSTRING(bufref):
	return re.split(r'\x00', bufref)

primative_fromraw["CSTRING"] = primative_fromraw_CSTRING

def primative_toraw_CSTRING(bufref, count):
	return bytes( join("\0", bufref) + "\0" ) if(count) else bytes()

primative_toraw["CSTRING"] = primative_toraw_CSTRING

# store UB as integers in memory.
def primative_toraw_UB(bufref, n):
	n = int(n)
	count = math.ceil(n/8)
	if(packmod_bits == '>'):
		n = n >> (32 - n)
	return struct.pack(packmod_bits + 'I', int(bufref[0]))[-count:]

primative_toraw["UB"] = primative_toraw_UB

def primative_toraw_SB(bufref, n):
	n = int(n)
	count = math.ceil(n/8)
	return struct.pack(packmod_bits + 'i', int(bufref[0]))[-count:]

primative_toraw["SB"] = primative_toraw_SB

def primative_toraw_SKIPBITS(bufref, n):
	return None

primative_toraw["SKIPBITS"] = primative_toraw_SKIPBITS
primative_toraw["SKIPBYTE"] = primative_toraw_SKIPBITS

def primative_fromraw_F64(bufref, x):
	return unpack_double(bufref)

primative_fromraw["F64"] = primative_fromraw_F64

def primative_toraw_F64(bufref, x):
	return pack_double(bufref)

primative_toraw["F64"] = primative_toraw_F64

def primative_fromraw_F32(bufref, x):
	return unpack_float(bufref)

primative_fromraw["F32"] = primative_fromraw_F32

def primative_toraw_F32(bufref, x):
	return pack_float(bufref)

primative_toraw["F32"] = primative_toraw_F32

def primative_fromraw_UI32(bufref, count):
	return struct.unpack(packmod + str(int(count)) + 'I', bufref)

primative_fromraw["UI32"] = primative_fromraw_UI32

def primative_fromraw_UI8(bufref, count):
	return struct.unpack(f'{count}B', bufref)

primative_fromraw["UI8"] = primative_fromraw_UI8

def primative_toraw_UI8(bufref, count):
	bufref = [int(n) for n in bufref] #FIXME remove
	return struct.pack(packmod + str(count) + 'B', *bufref)

primative_toraw["UI8"] = primative_toraw_UI8

def ui16tofixed(values):
	out = []
	for value in (values):
		v1 = value >> 8
		v2 = value & 0xff
		out.append(v1 + v2/0x100)

	return tuple(out)

def fixedtoui16(values):
	out = []
	for value in (values):
		v1 = int(value)
		v2 = int((value - v1) * 0x100)
		out.append((v1 << 8) | v2)
	return ([int(n) for n in out])

def primative_fromraw_UF16(bufref, x):
	return ui16tofixed(struct.unpack(ui16_pack, bufref))

primative_fromraw["UF16"] = primative_fromraw_UF16

def primative_toraw_UF16(bufref, x):
	return struct.pack(ui16_pack, *fixedtoui16(bufref))

primative_toraw["UF16"] = primative_toraw_UF16

def primative_fromraw_UI16(buf, count):
	return struct.unpack(packmod + str(int(count)) + 'H', buf)

primative_fromraw["UI16"] = primative_fromraw_UI16

def primative_toraw_UI16(bufref, count):
	if(bufref is None): return None
	bufref = [int(n) for n in bufref] #FIXME remove
	return struct.pack(packmod + str(count) + 'H', *bufref)

primative_toraw["UI16"] = primative_toraw_UI16

# pad INT24 to UI32's
def primative_fromraw_INT24(bufref, x):
	data = struct.unpack('C*', bufref)
	bufout = []
	while(len(data)):
		n = data[0:3]
		data = data[3:]
		unshift(n, 0); # add high byte
		bufout.append(struct.unpack("N", struct.pack("C4", n)))
	return bufout

primative_fromraw["INT24"] = primative_fromraw_INT24
	
def primative_toraw_INT24(bufref, x):
	data = bufref

	bufout = []
	while(len(data)):
		n = struct.unpack("C4", pack("N", shift(data)))
		shift(n); # remove high byte
		bufout.append(n)

	return pack('C*', bufout)

primative_toraw["INT24"] = primative_toraw_INT24

def primative_toraw_UI32(bufref, count):
	if(bufref is None or count == 0): return bytes()
	bufref = [int(n) for n in bufref] #FIXME remove
	return struct.pack(packmod + str(int(count)) + 'I', *bufref)

primative_toraw["UI32"] = primative_toraw_UI32

def primative_tostring_EVAL(dataref, n, t):
	return dataref
primative_tostring["EVAL"] = primative_tostring_EVAL

def primative_fromstring_EVAL(s, n, t):
	return tuple([int(s)]) if s is not None else None

primative_fromstring["EVAL"] = primative_fromstring_EVAL

def primative_tostring_HEXDATA(bufref, x1, x2):
	return bufref.hex() if bufref is not None else ""

primative_tostring["HEXDATA"] = primative_tostring_HEXDATA

def primative_tostring_UUDATA(bufref):
	s = pack("u", bufref)
	if(len(s) > 60):
		s = "\n" + s
	else:
		s = re.sub('\n$', '', s)
	return s

primative_tostring["UUDATA"] = primative_tostring_UUDATA

def primative_tostring_BITVECTOR(bufref, count, trans):
	# FIXME move int conversion to proper place
	count = int(count)
	setbits = []
	i = count - 1
	for b in ((''.join(['{:08b}'.format(n) for n in (bufref)]))[0:count]):
		if(int(b)): setbits.append(i)
		i-=1
	return ','.join([str(translate1(trans,x)) for x in setbits])

primative_tostring["BITVECTOR"] = primative_tostring_BITVECTOR

def primative_fromstring_BITVECTOR(instr, count, rtrans):
	count = int(count)
	setbits = {}
	for n in (translate(rtrans,instr.split(','))):
		setbits[n] = 1
	n = 0
	shift = 0
	for shift in setbits.keys():
		n = n | ( 1 << int(shift))
	sizebits = math.ceil(count / 8)
	return struct.pack(packmod_bits + "I", n)[-sizebits:]

primative_fromstring["BITVECTOR"] = primative_fromstring_BITVECTOR



def primative_tostring_SKIPBITS():
	return None

primative_tostring["SKIPBITS"] = primative_tostring_SKIPBITS
primative_tostring["SKIPBYTE"] = primative_tostring_SKIPBITS

def primative_fromstring_SKIPBITS(instr, n):
	return bytes(n)

primative_fromstring["SKIPBITS"] = primative_fromstring_SKIPBITS
primative_fromstring["SKIPBYTE"] = primative_fromstring_SKIPBITS

def primative_tostring_BITBITS(bufref, n):
	return struct.unpack(f"B{n}", bufref)

primative_tostring["BITBITS"] = primative_tostring_BITBITS

def primative_fromstring_BITBITS(instr, n):
	return struct.pack("B*", instr)

primative_fromstring["BITBITS"] = primative_fromstring_BITBITS

def primative_tostring_HEXBITS(bufref, n, t):
	return bufref.hex()

primative_tostring["HEXBITS"] = primative_tostring_HEXBITS

def primative_fromstring_HEXBITS(instr, n, t):
	return bytes.fromhex(instr)

primative_fromstring["HEXBITS"] = primative_fromstring_HEXBITS

def primative_fromstring_HEXDATA(instr, n, t):
	return bytes.fromhex(instr)

primative_fromstring["HEXDATA"] = primative_fromstring_HEXDATA

def primative_fromstring_UUDATA(instr):
	instr = re.sub(r'^\n', '', instr)

	return struct.unpack("u", instr)

primative_fromstring["UUDATA"] = primative_fromstring_UUDATA

def primative_tostring_CHAR(bufref, n, trans):
	buf = struct.unpack(str(n) + "s", bufref)[0].decode('UTF-8')
	n = buf.find("\0")
	if(n >= 0): buf = buf[:n]
	return (translate(trans, [buf]))[0]

primative_tostring["CHAR"] = primative_tostring_CHAR

def primative_fromstring_CHAR(instr, n, rtrans):
	if(rtrans != None): (instr) = translate1(rtrans, instr)
	return(bytes(instr, 'UTF-8'))

	if(n == None or len(instr) == n):
		return instr
	return struct.pack(f"{n}s", instr)

primative_fromstring["CHAR"] = primative_fromstring_CHAR

def primative_tostring_UI8(bufref,count,trans):
	if not (isinstance(bufref, tuple) or isinstance(bufref, list)): bufref = tuple([bufref]) # FIXME remove

	return ','.join([str(translate1(trans,x)) for x in bufref])

primative_tostring["UI8"] = primative_tostring_UI8
primative_tostring["UF16"] = primative_tostring_UI8
primative_tostring["UI16"] = primative_tostring_UI8
primative_tostring["INT24"] = primative_tostring_UI8
primative_tostring["UI32"] = primative_tostring_UI8
primative_tostring["F32"] = primative_tostring_UI8
primative_tostring["F64"] = primative_tostring_UI8
primative_tostring["UB"] = primative_tostring_UI8
primative_tostring["SB"] = primative_tostring_UI8
primative_tostring["CSTRING"] = primative_tostring_UI8

def primative_fromstring_UI8(instr,count,rtrans):
	if instr is None: return None
	if(isinstance(instr, int)): return ([instr])
	return ([translate1(rtrans, get_value(s)) for s in instr.split(',')])

primative_fromstring["UI8"] = primative_fromstring_UI8
primative_fromstring["UI16"] = primative_fromstring_UI8
primative_fromstring["UF16"] = primative_fromstring_UI8
primative_fromstring["INT24"] = primative_fromstring_UI8
primative_fromstring["UI32"] = primative_fromstring_UI8
primative_fromstring["F32"] = primative_fromstring_UI8
primative_fromstring["F64"] = primative_fromstring_UI8
primative_fromstring["UB"] = primative_fromstring_UI8
primative_fromstring["SB"] = primative_fromstring_UI8
primative_fromstring["CSTRING"] = primative_fromstring_UI8

def fdata_value(fdata):
	return(fdata[0] if (isinstance(fdata, list) or isinstance(fdata, tuple)) else fdata)

def struct_read(stype, parent_structs = None, struct_start = 0, struct_end = None, array_last = None):
	if(debug): print("read struct: %x %x (%d)" % (INFILE.tell(), INFILE.tell() - struct_start, INFILE.tell() - struct_start))
	this_struct = {}
#	unless(defined(struct_start)):
#		struct_start = INFILE.tell();

	if(parent_structs == None):
		parent_structs = []

	if(array_last == None):
		this_array_last = 0
		array_last = this_array_last

	for name_fields in (structs[stype]):
		(fname, fields) = name_fields
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fields


		ftype = expand_struct_type(struct_fields[stype], this_struct, ftype)
		ftrans = expand_struct_type(struct_fields[stype], this_struct, ftrans)

		# empty fcount means remaining bits or everything
		if(fcount is None or fcount == ''):
			fcountset = None
			if(ftype in primative_sizebits): sizebits = primative_sizebits[ftype]
			else: sizebits = struct_size(ftype)
			if(sizebits == 1):
				fcount = read_bits_buf8size
			else:
				pos = INFILE.tell()
				endpos  = struct_end
				if(endpos == None):
					INFILE.seek(0, 2)
					endpos = INFILE.tell()
					INFILE.seek(pos, 0)
				if(sizebits is not None):
					fcount = int ((endpos-pos) * 8/sizebits)
				else:
					fcount = None
		else:
			(fcount, fcountset) = struct_expression(struct_fields[stype], this_struct, fcount, parent_structs, 0)
			#continue unless(fcount)
			#print(f"count: {fcount}, {fcountset}")
		if(fcount is not None and fcount == 0):
			this_struct[fname] = (None, 0, 0)
			continue
		if(debug): print("pos: " + str(INFILE.tell()))
		if(debug): print(f"read: {stype}: {ftype}, name={fname}, count = {fcount}, offset={foffset} LAST {array_last}")

		if(fcountset is None):
			fcountset = fcount
		elif( None is not fcount and fcountset > fcount):
			print("count set too large", file=sys.stderr)
			fcountset = fcount
		#print(f"pcount in: {fpcount}")

		(fpcount, fpcountset) = struct_expression(struct_fields[stype], this_struct, fpcount, parent_structs, None)
		#print(f"pcount: {fpcount}")
		if(fpcountset == None or fpcountset <= fpcount):
			fpcountset = fpcount
		if(foffset is not None):
			(foffset, x) = struct_expression(struct_fields[stype], this_struct, foffset, parent_structs, struct_start)
			if(foffset == None): continue
			pos = INFILE.tell()

			if(0 > INFILE.seek(struct_start + foffset,0)):
				print(f"seek error", file=sys.stderr)

		if(debug): print (f"off: ({ftype}) %x %x + %d" % ( INFILE.tell(), INFILE.tell() - struct_start, read_bits_buf8size))
		#fvalue = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs, 0)
		#	if(defined(fvalue))
		fdata = None
		if(ftype in primative_sizebits):
			buf = read_bits(INFILE, fcount *
				primative_sizebits[ftype])
			if (None is (buf) or len(buf) == 0): return None

			fdata = primative_fromraw[ftype](buf, fcountset)


			#if(debug): print("fdata value : " + str(fdata_value(fdata)))
# assertion not ready
#			print("assertion failed: ", fdata_value({fdata}), " != {fvalue})
		#		if(None is not(fvalue) and ! fdata_equals(fdata, fvalue))
		elif(ftype in primative_read):
			buf = primative_read[ftype](INFILE, fcount)
			fdata = primative_fromraw[ftype](buf, fcountset)
#			print(f"assertion failed: ", fdata_value({fdata}), " != {fvalue}")
#				if(defined(fvalue) and ! fdata_equals(fdata, fvalue));
		elif(ftype in structs):
			#print(f"struct in: {ftype} ({fcountset} of {fcount})")
			array_last = 0

			parent_structs.append(this_struct)
			i = 0
			fdata = []
			while(fcountset is None or i < fcountset):
				s = struct_read(ftype, parent_structs,struct_start, struct_end, array_last)
				if None is (s): break
				fdata.append(s)

				if(None is not (array_last) and ( array_last == 1 or array_last == ftype)):
					array_last = 0
					break
				if(None is not (struct_end) and INFILE.tell() >= struct_end): break
				i += 1
			parent_structs.pop()

			countunset = None if None is fcount else fcount - fcountset
			if(debug): print(f"reads: {ftype} {fcountset},{fcount}")
			if(countunset): read_bits(INFILE, countunset *
				struct_size(ftype))
		# TODO: should evaluate all at end of struct. put in function shared by struct_read_xml
		elif(ftype == "EVAL"):
			(fvalue, x) = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs, 0)
			fdata = fvalue

		else:
			print(f"unknown type: {ftype}", file=sys.stderr)

		if(ftype == "EVAL"):
			if(fname == "DATA_END"):
				struct_end = INFILE.tell() + fdata
				continue
			if(fname == "OFFSET_START"):
				struct_start = INFILE.tell()
				continue
			if(fname == "ARRAY_LAST" or fname == "LAST"):
				if(array_last != None): array_last = fdata
				continue
			if(fname == "BREAK"):
				if(array_last != None):
					array_last = fdata
					if(fdata):  break
					else: continue

		#print(f"set struct {fname} ({fcountset})")
		#if(debug): print("fdata x value : f", fdata_value(fdata))

		if(fdata != None): this_struct[fname] = (fdata, fcountset, fcount)

		# read in structs pointed to
		if(None is not (fptype) and ( isinstance(fdata, list) or isinstance(fdata, tuple))):
			fpdata = []
			#print(f"POINTER struct in: {fptype}")
			prevpos = INFILE.tell()
			#print(f"POINTER read {fcount} by {fpcount}")
			for i in range(fcount):
				if(fdata[i] is None): continue
				newpos = struct_start + fdata[i]
				#print(f"seek from {prevpos} to {newpos}")
				if(0 > INFILE.seek(newpos, 0)):
					print("seek error")
					continue

				parent_structs.append(this_struct)
				#fixme unwanted cast
				for pi in range(fpcount):
					fpdata.append(
						struct_read(fptype, parent_structs, struct_start, struct_end, array_last))

				parent_structs.pop()
				if None is not (fpdata): this_struct[fpname] = (fpdata, fpcountset, fpcount)
			INFILE.seek(prevpos, 0)
	#	INFILE.seek(pos, 0 ) if(None is not(pos))

	#remove hidden values (_evals or _values that match evaluation)
	for fname in (struct_fields[stype].keys()):
		#print STDERR "{stype}: {fname}\n"
		fieldref = struct_fields[stype][fname]
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fieldref

		if not (re.search(r'^_', fname)): continue
		this_struct.pop(fname)
		continue

		if(ftype == "EVAL"):
			this_struct.pop(fname)
		elif(None is not (fvalue)):
			fvalue0 = fvalue
			(fvalue, x) = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs, 0)
			(fdata) = this_struct[fname][0]
			fdata_value_ = fdata_value(fdata)
			if(fdata_value_ == fvalue):
				#print STDERR "data == value : {stype}, {fname}, {fdata}_value, {fvalue}\n"
				#this_struct[fname] = (None, 0, 0)
				this_struct.pop(fname)
			else:
				print("data != value : {stype}, {fname}, {fdata}_value, {fvalue} ({fvalue}0)", file=sys.stderr)
	#if(debug): print(f"read-out: {stype}: {ftype}, name={fname} LAST {array_last}")
	return this_struct

def expand_struct_type(fieldsref, structref, ftype):

	if(ftype == None): return None

	while(None != (m := re.search('\{([^\{\}]+)\}', ftype))):
		othername = m[1]
		(before, after) = (m.string[0:m.start()],m.string[m.end():])
		if(othername not in structref): othername = "*"
		if(othername not in structref): break
		otherfields = fieldsref[othername]
		if(None == otherfields): break
		(othertype, othercount, othertrans) = otherfields[0:3]
		(data, datacount) = structref[othername][0:2]
		if(None == data): break
		if(othertype not in primative_tostring): break
		s = primative_tostring[othertype](data, othercount, translations.get(othertrans))
#x
#		s = translations[othertrans][s]
#		if(defined(othertrans) and defined(translations[othertrans]) and defined(translations[othertrans][s]));

		s = str(s) # FIXME remove cast
		if(not ((before+s+after) in structs or (before+s+after) in translations)): s = "*"
		ftype = before + s + after
	return ftype

def expression_value(value):
	if None is (value): return "()"
	if(value == ''): return "''"
	if(isinstance(value,int)): return value
	if(re.search('[^\d]', str(value))): return f"'{value}'"
	return value

def data_expression_value(data):
	if(isinstance(data,list) or isinstance(data,tuple)):
	#	return data[0]
		size = len(data)
		# return break element
		return expression_value(data[size -1]) if size else 0
	elif(data):
		#buf2 += this_struct[m[1]][0]
		return expression_value(data)
	else:
		return expression_value(data)

def parent_data(parent_structs, name):
	structs = parent_structs.copy()
	while(len(structs)):
		struct = structs.pop()
		if(name in struct): return struct[name][0]

	return None

def parent_count(parent_structs, name):
	structs = parent_structs.copy()
	while(len(structs)):
		struct = structs.pop()
		if(name - struct): return struct[name][1]

	return None

def struct_expression(fieldsref, this_struct, buf, parent_structs, struct_start):
	if(not isinstance(buf, str)): return [buf, None]

	if(buf is None): return [None, None]
	if(None == re.search('\D', buf)): return [int(buf), None]
	buf2 = ''
	buf0 = buf
	while(m := re.search('count\(([A-Za-z_]\w*)\)', buf)):
		buf = m.string[m.end():]
		buf2 += m.string[0:m.start()]
		if(None != (this_struct[m[1]]) ):
			#buf2 += this_struct[m[1]][1]
			buf2 += len(this_struct[m[1]][0])
		elif(None != (fieldsref[m[1]])):
			buf2 += 0
		elif(None != (count := parent_count(parent_structs,m[1]))):
			buf2 += count

		else:
			buf2 += "count(m[1])"


	while(m := re.search('([A-Za-z_]\w*)', buf)):
		buf = m.string[m.end():]
		buf2 += m.string[0:m.start()]
		if(m[1] == "struct_start"):
			buf2 += struct_start
		elif(m[1] in this_struct):
			buf2 += str(data_expression_value(this_struct[m[1]][0]))
		elif(m[1] in fieldsref):
			buf2 += '0'

		elif(None is not (data := parent_data(parent_structs,m[1]))):
			buf2 += data_expression_value(data)

		else:
			buf2 += m[1]


	buf2 += buf
	rtn = eval(f"[{buf2}]")
	if(None is rtn or 0 == len(rtn) or None is rtn[0]): return [ None, None ]
	rtn = [int(n) for n in rtn]
	rtn.append(None)
	rtn = rtn[0:2]

	return rtn

# read unil token.
# return data read and remaining buffer
# if keep_token is not set, exclude token froom data read
def readline_until(file, filebuf, token, keep_token):
	tlen = len(token)
	klen = tlen if keep_token else 0

	if(0 <= (n := filebuf.find(token))):
		return (filebuf[0:n+klen], filebuf[n+tlen:])
	while('' != (data := file.readline())):
		if(0 <= (n := data.find(token))):
			return (filebuf + data[0:n+klen], data[n+tlen:])
		print(f"looking {n} {token} in {filebuf},{data} {len(data)}")
		filebuf += data
	return (None, filebuf)

def string_to_data(fieldsref, structref, fname, fdata_value, parent_structs):
	(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount ) = fieldsref[fname]

	struct_start = None

	ftype = expand_struct_type(fieldsref, structref, ftype)
	ftrans = expand_struct_type(fieldsref, structref, ftrans)

	#fvalue = struct_expression(fieldsref, structref, fvalue, parent_structs)
#	print(f"assertion failed: {fdata} != {fvalue}")
#	if not (fdata_equals(fdata, fvalue));

	(fcount, fcountset) = struct_expression(fieldsref, structref, fcount, parent_structs, struct_start)
	if(fcountset is None or fcountset > fcount): fcountset = fcount
	#print(f"pcount in: {fpcount}\n"

	if(ftype in primative_fromstring):
#x
#		if(defined(ftrans) and defined(reverse_translations[ftrans]) and defined reverse_translations[ftrans][fdata_value])
#			fdata_value = reverse_translations[ftrans][fdata_value];

		fdata = primative_fromstring[ftype](fdata_value, fcountset, reverse_translations[ftrans] if ftrans in reverse_translations else None)
		#if(fcountset is None and (isinstance(fdata, list) or isinstance(fdata, tuple))):
		if None is (fcountset): fcountset = fcount = math.ceil(len(fdata)*8/primative_sizebits[ftype])

	else:
		print(f"non primative paramater: {fname} ({ftype})", file=sys.stderr)

	return (fdata, fcountset, fcount)

def struct_read_xml(stype, name = None, params = '', parent_structs = None):

	struct_start = None
	(params, singletag) = re.subn(r'/$', '', params)
	singletag = True if singletag > 0 else False

	this_struct = {}

	while(None is not (m := re.match('^\s*(\w+)\s*=\s*\"([^\"]*)\"\s*', params))):
		param_name = m[1]
		param_value = m[2]
		params = m.string[m.end():]

		this_struct[param_name] = string_to_data(struct_fields[stype], this_struct, param_name, param_value, parent_structs)
#TODO check is struct_fields[stype] correct

	#return this_struct if(m)
	

#	for name ( struct_fields[stype].keys() ):
#		this_struct[name] = (None, 0, 0);

	if(parent_structs == None): parent_structs = []
	
	infile_buf = ''
	while(not singletag):
		(tag, infile_buf) = readline_until(INFILE, infile_buf, ">", True)
		if(tag == None): break
		if(None == re.search('\S', tag)): break
		if(None == (m := re.search('^\s*\<\s*([^\>\s]+)([^\>]+)*\>$', tag))):
			print(f"{stype}: did not get expected tag in {name}: {tag}")
			break

		fname = m[1]
		params = m[2]

		if(fname == f"/{name}"): break

		if(fname[-1] == '/'): continue

		if(fname in struct_fields[stype]):
			fieldref = struct_fields[stype][fname]
			#print(f"xx {fname} {struct_fields[stype]}")
			#print(f"xx {fname} {struct_fields[stype][fname]}")
			(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fieldref
			fdata = []
			# add sequential structure
			if(fname in this_struct):
				fdata = this_struct[fname][0]
			#(fcountset, fpcountset)

			if(ftype == "EVAL"): continue # handled in write

			ftype = expand_struct_type(struct_fields[stype], this_struct, ftype)
			ftrans = expand_struct_type(struct_fields[stype], this_struct, ftrans)

#			if(defined(fvalue)):
#				fvalue = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs);
#				print f"assertion failed: {fdata} != {fvalue}"
#					unless(fdata_equals(fdata, fvalue));

			(fcount, fcountset) = struct_expression(struct_fields[stype], this_struct, fcount, parent_structs, struct_start)
			#if not (fcount): continue
			if(fcountset is None or fcountset > fcount):
				fcountset = fcount
			#print f"pcount in: {fpcount}"
			(fpcount, fpcountset) = struct_expression(struct_fields[stype], this_struct, fpcount, parent_structs, struct_start)
			if(fpcountset is None or fpcountset > fpcount):
				fpcountset = fpcount

			if(ftype in primative_fromstring):
				(data, infile_buf) = readline_until(INFILE, infile_buf, f"</{fname}>", False)

				if(data == None):
					print(f"incomplete field: {fname}", file=sys.stderr)
					break
#x
#				if(ftrans is not None and ftrans in reverse_translations and data in reverse_translations[ftrans]):
#					data = reverse_translations[ftrans][data];

				fdata = primative_fromstring[ftype](data, fcountset, reverse_translations[ftrans] if ftrans in reverse_translations else None)
				if(fcountset == None): fcountset = fcount = ceil(length(fdata)*8/primative_sizebits[ftype])
			elif(ftype in structs):
				parent_structs.append(this_struct)
				fdata.append(struct_read_xml(ftype, fname, params, parent_structs))
				parent_structs.pop()
				if(fcountset == None): fcountset = fcount = fdata
			#elif(ftype == "EVAL"): continue
			#elif(ftype == "EVAL"):
			#	(fvalue) = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs)
			#	fdata = fvalue
			this_struct[fname] = (fdata, fcountset, fcount)
			rr = this_struct
			if(debug): print(f"xmlin {len(rr)} {ftype} {len(fdata)} {fname} {fcount} {fcountset}")
		else:
			print(f"no such field: {fname} in {stype}")

	# evaluate undefined EVALS
	for fname in (struct_fields[stype].keys()):
		fieldref = struct_fields[stype][fname]
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fieldref
		fdata = this_struct[fname][0] if fname in this_struct else None

		if(ftype != "EVAL"): continue
		if(fvalue == None or fdata != None): continue

		(fvalue, x) = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs, 0)
		#this_struct[fname][0] = fvalue
		this_struct[fname] = (fvalue, 1, 1)

	# evaluate undefined data
	for fname in (struct_fields[stype].keys()):
		fieldref = struct_fields[stype][fname]
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fieldref

		fdata = this_struct[fname][0] if fname in this_struct else None

		if(ftype == "EVAL"): continue
		if(fdata is not None or fvalue is None): continue

		(fvalue, x) = struct_expression(struct_fields[stype], this_struct, fvalue, parent_structs, 0)
		if(None == primative_fromstring[ftype]): continue
		(fdata) = primative_fromstring[ftype](fvalue, fcount, ftrans)
		fcount = fdata if (isinstance(fdata, list) or isinstance(fdata,tuple)) else 1

		this_struct[fname] = (fdata, fcount, fcount)

	# re-evaluate data counts. size may have changed from above evaluation
	for fname in (struct_fields[stype].keys()):
		fieldref = struct_fields[stype][fname]
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fieldref

		if(fname not in this_struct): continue
		(fdata) = this_struct[fname][0]
		(fcount, fcountset) = struct_expression(struct_fields[stype], this_struct, fcount, parent_structs, struct_start)
		#CHECK
		this_struct[fname] = (fdata, fcount, fcount)
	return  this_struct

def struct_write(stype, structref, parent_structs, struct_start, struct_end, array_last):


	if(None is  parent_structs):
		parent_structs = []
	
	if(None is structref):
		print("undefined structure", file=sys.stderr)
		return

	if None is (struct_start): struct_start = 0

	for name_fields in (structs[stype]):
		(fname, fields) =  name_fields

		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpcount) = fields
		ftype = expand_struct_type(struct_fields[stype], structref, ftype)
		ftrans = expand_struct_type(struct_fields[stype], structref, ftrans)

		ftotalcount = None
		fdata = None

		if(fname in structref):
			(fdata, fdatacount, ftotalcount) = structref[fname]
# done in read
#		elif(ftype != "EVAL" and None != (fvalue)):
#			(fvalue) = struct_expression(struct_fields[stype], structref, fvalue, parent_structs, 0);
#			#print STDERR "filled in value {stype} {fname}: {fvalue}\n";
#			fdata = primative_fromstring[ftype](fvalue, 1);
#			fdatacount = ftotalcount = 1;
#			structref[fname] = (fdata, fdatacount, ftotalcount);

		if(ftype == "EVAL"):
			if None is not (fvalue): (fdata, x) = struct_expression(struct_fields[stype], structref, fvalue, parent_structs, 0)
			if(fname == "OFFSET_START"):
				struct_start = OUTFILE.tell()
				continue
			if(fname == "ARRAY_LAST" or fname == "LAST"):
				array_last = fdata
				continue
			elif(fname == "BREAK"):
				array_last = fdata
				if(fdata): break
				else: continue
			continue


		# handle unread type
		if(None is (ftotalcount)):
			(ftotalcount, fcount) = struct_expression(struct_fields[stype], structref, fcount, parent_structs, struct_start)
			#print(f"warning {ftype} {fname}  {fdatacount}, {ftotalcount} {fcount}")
			#ftotalcount = fcount

		prevpos = None

		if(None != (foffset)):
			(foffset, x) = struct_expression(struct_fields[stype], structref, foffset, parent_structs, struct_start)
			if(not foffset): continue
			if(0 > (n := OUTFILE.seek(struct_start + foffset, 0))):
				print(f"seek error: {n}")
			#if(debug): print(f"off: %d(%x) %d(%x) + %d" % (OUTFILE.tell(), OUTFILE.tell(), OUTFILE.tell() - struct_start, OUTFILE.tell() - struct_start, write_bits_buf8size))

		if(fdata is None):
			if(debug): print(f"no data for {fname} {ftype}")

		#check struct or structs
		parent_structs.append(structref)
		write_type(OUTFILE, ftype, fdata, ftotalcount, fname, parent_structs, struct_start, struct_end, array_last)
		parent_structs.pop()

		if not(
			None is not (fptype) and
			None is not (fpname) and
			fpname in structref and
			(isinstance(fdata, tuple) or isinstance(fdata, list)) and
			len(fdata)): continue


		(fpdata, fpdatacount, fptotalcount) = structref[fpname]
		if(not (isinstance(fpdata, list) or isinstance(fpdata, tuple))): continue
		(fpdatasplit) = array_split(fpdatacount, fpdata)

		parent_structs.append(structref)
		for i in range(len(fdata)):
			offset = fdata[i]
			data = fpdatasplit[i]
			if not (offset): print(f"warning zero offset in {ftype} {fptype}")
			prevpos = OUTFILE.tell()
			if(0 > (n := OUTFILE.seek(struct_start + int(offset), 0))):
				print(f"seek error: {n}")
			#print(f"seekp to {struct}_start + {offset}")
			if(debug): print("{fptype} {fptotalcount}", file=sys.stderr)
			write_type(OUTFILE, fptype, data, fptotalcount, fpname, parent_structs, struct_start, None, None)
			OUTFILE.seek(prevpos, 0)
		parent_structs.pop()

def array_split(count, data):
	out = []
	while(len(data)):
		part = data[0:count]
		data = data[count:]
		out.append(part)
	return out

def write_type(fh, stype, data, count, name, parent_structs, struct_start, struct_end, array_last):
	if(count == ''): count = None

	if(debug): print(f"write_type {stype} {count} {name}")

	if(stype in primative_toraw):
		refout = primative_toraw[stype](data, count)
		if(stype in primative_sizebits):
			if(count is None):
				if(refout is None):
					# write remaining bits (SKIPBITS[])
					if(1 == primative_sizebits[stype]):
						count = 8 - write_bits_buf8size
				else:
					count = (len(refout) * 8 + write_bits_buf8size) % primative_sizebits[stype]

			refout = write_bits(fh, refout, int(count) * primative_sizebits[stype])
		else:
			refout = write_bits(fh, refout, len(refout) *8)

		#if(debug):
			#p = fh.tell()
			#s = primative_tostring[stype](data, count)
			#print(f"write  {p} {stype} {count} s {s}")
	elif(stype in structs):
		#print("write stype {stype}")
		write_structs(OUTFILE, stype, data, count, parent_structs, struct_start, struct_end, array_last)
	else:
		print(primative_toraw)
		print(f"unknown stype {stype}", file=sys.stderr)

#
def write_structs(fh, stype, structs_ref, fcount, parent_structs, struct_start, struct_end, array_last):
	if(fcount == ''): fcount = None
	fcounthave = 0

	if(None is not (structs_ref)):
		refs = ( structs_ref ) if ( isinstance(structs_ref, list) or isinstance(structs_ref, tuple)) else ( structs_ref )
		for struct_ref in (refs):
			struct_write(stype, struct_ref, parent_structs, struct_start, struct_end, array_last)
			fcounthave += 1

	if None is (fcount): return

	fcountunset = fcount - fcounthave

	if(fcountunset < 0): print(f"too many {fcount} ({fcountunset}) {stype}", file=sys.stderr)
	if(fcountunset >0):
		#print(f"unset count {fcountunset} in a {stype}")
		#print(f"wt2 {stype} {fcount} {fcountunset}")
		write_bits(fh, None, struct_size(stype) *
			fcountunset)

def data_has_value(data):
	if None is (data): return 0
	if(isinstance(data, list) and len(data) == 0): return 0
	#print("ref " + ref {data} + "{data}")
	return 1

def get_primative_param_string(stype, structref):
	value_sets = []
	if(stype not in structs): return ''

	for name_fields in (structs[stype]):
		(fname, fields) =  name_fields
		if(fname not in structref): continue
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpsize) = fields
	
		ftype = expand_struct_type(struct_fields[stype], structref, ftype)
		if(ftype not in primative_tostring): continue

		ftrans = expand_struct_type(struct_fields[stype], structref, ftrans)
		(fdata, fdatacount, fouter) = structref[fname][0:3]
		if(fdata is None): continue

		(value) = primative_tostring[ftype](fdata, fdatacount, translations.get(ftrans))
#x
#		if(defined(ftrans) and
#			defined(translations[ftrans]) and
#			defined(translations[ftrans][value]))
#		{
#			value = translations[ftrans][value]
#		}

		value_sets.append(f"{fname}=\"{value}\"")
	return ' '.join(value_sets)

def struct_write_xml(stype, name, structref, indent):
	tag_params = get_primative_param_string(stype, structref) if minimal_xml else ""
	if(tag_params != ''): tag_params = " " + tag_params

	if(indent is None): indent = ""
	indent0 = indent

	if(stype not in structs):
		print(f"unknown struct: {stype}", file=sys.stderr)
		return

	if not (structref): return

	if( stype != "MAIN"):
		if(stype != "MAIN"): OUTFILE.write(f"{indent0}<{name}{tag_params}")
		indent += "\t"

	count = 0

	for  name_fields in (structs[stype]):
		(fname, fields) =  name_fields
		(ftype, fcount, ftrans, fvalue, foffset, fptype, fpname, fpsize) = fields
		ftype = expand_struct_type(struct_fields[stype], structref, ftype)
		ftrans = expand_struct_type(struct_fields[stype], structref, ftrans)
		if(ftype == "OFFSET_START"): continue
		if(fname not in structref): continue
		(fdata, fdatacount, fcount) = structref[fname]
		if(not data_has_value(fdata)): continue
		if(debug): print(f"xml out {fname}, {ftype}, {fcount}")
		if(debug): print("fdata out value : "+ str(fdata_value(fdata)))

		if (ftype not in primative_tostring and ftype != "EVAL"):
			if(not(len(fdata) > 1 or len(fdata) == 1 and fdata[0])): continue
		elif(minimal_xml and (None == fptype and stype != "MAIN")):
			continue

		#continue if (minimal_xml and (not defined(fptype)) and stype != "MAIN" and (defined(primative_tostring[ftype]) or ftype == "EVAL"))

		if not (count or stype == "MAIN"): OUTFILE.write(">\n")

		count += 1
		if(ftype not in primative_tostring and ftype != "EVAL"):
			for substructref in (fdata):
				struct_write_xml(ftype, fname, substructref, indent)
		elif(stype == "MAIN" or not minimal_xml):
			if(ftype == "EVAL"):
				strout = fdata

			else:
				if(0 and debug):
					p = OUTFILE.tell()
					r = primative_toraw[ftype](fdata, fdatacount)
					strout = unpack("H*", r)
				else:
					strout = primative_tostring[ftype](fdata, fdatacount, translations[ftrans] if ftrans in translations else None);
#x
#			if(defined(ftrans) and
#			 defined(translations[ftrans]) and
#			 defined(translations[ftrans][strout])):
#				strout = translations[ftrans][strout];
			OUTFILE.write(f"{indent}<{fname}>{strout}</{fname}>\n")

		if None is (fptype): continue
		(fpdata, fpdatacount, fcount) = structref[fpname]

		if(fptype in primative_tostring):
			strout = primative_tostring[fptype](fpdata, fpdatacount)
			OUTFILE.write(f"{indent}<{fpname}>{strout}</{fpname}>\n")
		else:
			for substructref in (fpdata):
				struct_write_xml(fptype, fpname, substructref, indent)
	if(stype != "MAIN"): OUTFILE.write(f"{indent0}</{name}>\n" if (count) else "/>\n")

def struct_size(stype):
	size = 0
	for name_fields in (structs[stype]):
		(fname, fields) =  name_fields
		(ftype, fcount,ftrans, fvalue, foffset, fptype, fpname, fpcount) = fields
		if(ftype == "OFFSET_START"): continue
		if(isinstance(fcount, str) and re.search('[^\d]', fcount)):
			if(debug): print(f"warn attempt to get size of dynamic({fcount})  stype {ftype} {fname} in {stype}")
			return None
		fcount = int(fcount) if fcount is not None else 0
		if None is not (foffset):
			print(f"error: attempt to get size of irregular struct: offset: {foffset}")
		if(ftype in structs):
			ssize = struct_size(ftype)
			size = ssize if ssize != None else None
		elif(ftype in primative_sizebits):
			size += fcount * primative_sizebits[ftype]
		else:
			if(debug): print(f"warn no size info for '{ftype}'")
			size = None
	return size

def fdata_equals(fdata, fvalue):
	return(fdata_value(fdata) == fvalue)

while(1):
	#m = re.match(m%^\s*([\w]+\*?):\s*\n\s*([^:]*)\s*\n:\n%s, text)

	if(None != (m := re.match('^\s*([\w]+\*?):\s*\n\s*(.*?):\n', text, re.S))):
		structname = m[1]
		fields = m[2]
		if(debug): print(f"struct: {structname}")
		structs[structname] = []
		struct_fields[structname] = {}


		text = m.string[m.end():]
#		print(text, file=sys.stderr)

		i = 1
		for field in (re.split('\s*\n\s*', fields)):
			if(field == ""): continue
			m = re.search(
				r'(\[([^\]]*)\]\s*)?' + # [2]
				r'(([\w{}]+)(\s*\[([^\[\]]+)\])?\@)?' + # 4[6]@
				r'([\w{}]+)(\s*\[([^\[\]]*)\])?' + # 7[9]
				r'(\s+\<([\w{}]+)\>)?' + # <11>
				r'(\s+((\w+)\@)?(\w+))?' + # 14@15
				r'(\s=\s*(.*))?', # =17
				field)
			if None is (m): print(f"ERROR {field}")
			(offset, ptype, pcount, stype, count, trans, pname, name, value) = (m[2], m[4], m[6], m[7], m[9], m[11], m[14], m[15], m[17])
			if(debug): print('(offset, ptype, pcount, stype, count, trans, pname, name, value) = ' + f"{offset}, {ptype}, {pcount}, {stype}, {count}, {trans}, {pname}, {name}, {value}")
			if(count == None): count = 1
			elif(count == ''): count = None
			#else: count = int(count)
			if(name == None): name = stype + str(i)
			if(ptype != None):
				if(pcount == None): pcount = 1
				#else: pcount = int(pcount)
				fields = [ stype, count, trans, value, offset, ptype, pname, pcount ]
				structs[structname].append([ name, fields ])
				struct_fields[structname][name] = fields
				# when reading xml, we need the ptypes as fields too
				struct_fields[structname][pname] = [ ptype, pcount, None, None, None, None, None, None ]
			else:
				fields = [ stype, count, trans, value, offset, None, None, None ]
				structs[structname].append([name, fields ])
				struct_fields[structname][name] = fields
			i+=1

	elif(None != (m := re.match('^\s*([\w\d]*)=$([^=]+)^=$', text, re.S | re.M))):
		if(m[1] == ''):
			(file_settings) = parse_translation(m[2])[0]
		else:
			(translations[m[1]], reverse_translations[m[1]]) = parse_translation(m[2])
		text = m.string[m.end():]
	else:
		if(None != re.search('\S', text, re.S)):
			print(f"no match: {text}", file=sys.stderr)
		break

for structname in (sorted(list(structs))):
	if (debug): print(f"struct {structname}")
	for name_fields in (structs[structname]):
		(name, fields) = name_fields
		(stype, count, trans, value, offset, ptype, pname, pcount) = fields
		if(debug): print(f"fields: stype {stype}, name {name}, size {count}")

if("BYTE_ORDER" not in file_settings):
	pass
elif(file_settings["BYTE_ORDER"] == 'vax'):
	packmod = '<'
	packmod_bits = packmod
	ui32_pack = 'I'
	ui16_pack = 'H'
	f32_reverse_bytes = 1
	uib32_pack = 'V'

elif(file_settings["BYTE_ORDER"] == 'vax_swf'):
	packmod = '<'
	packmod_bits = '>'
	ui32_pack = packmod + 'I'
	ui16_pack = packmod + 'H'
	f32_reverse_bytes = 1
	f32_reverse_ints = 1
	uib32_pack = packmod_bits + 'I'

elif(file_settings["BYTE_ORDER"] == 'vax_except_bits'):
	packmod = '<'
	ui32_pack = packmod + 'I'
	ui16_pack = packmod + 'H'
	f32_reverse_bytes = 1
	uib32_pack = packmod_bits + 'I'

if(re.search('\.xml$', infile)):
	print("xml to raw")
	INFILE = open(infile, "r")
	OUTFILE = open(outfile, "wb")
	mainref = struct_read_xml("MAIN")
	#struct_write_xml("MAIN", "", mainref)
	struct_write("MAIN", mainref, None, None, None, None)
	INFILE.close()
	if("SECTOR_SIZE" in file_settings):
		OUTFILE.seek(0,2)
		remain = OUTFILE.tell() % int(file_settings["SECTOR_SIZE"])
		if(remain): remain = 2048 - remain
		buf = bytes(remain)
		OUTFILE.write(buf)
	OUTFILE.close()
elif(re.search('\.xml$', outfile)):
	print("raw to xml")
	INFILE = open(infile, "rb")
	OUTFILE = open(outfile, "w")
	mainref = struct_read("MAIN")
	struct_write_xml("MAIN", "", mainref, "")
	INFILE.close()
	OUTFILE.close()
else:
	INFILE = open(infile, "rb")
	OUTFILE = open(outfile)
	mainref = struct_read("MAIN")
	struct_write("MAIN", mainref)
	INFILE.close()
	INFILE.close()
	print("unknown conversion")


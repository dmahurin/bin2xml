#!/usr/bin/perl
# bin2xml
# Tool to convert binary files of known formats to/from free
# format xml. The binary specification file allows for: primative
# types, structs, struct pointers and translations.
#
# -don mahurin

#use strict;

use POSIX;

my $ui32_pack = 'N';
my $uib32_pack = 'N';
my $ui16_pack = 'n';
my $reverse_float_bytes = 0;
my $reverse_double_ints = 0;

my $bitbufin = '';
my $bitbufout = '';

my %translations;
my %reverse_translations;
my $file_settings;

#my $debug = 1;

my $minimal_xml = 1;

my $reverse_byte_native_floats;
{
	my $n125 = unpack('N', pack("f", -1.25));
	if($n125 == 0xa0bf) { $reverse_byte_native_floats = 1; }
	elsif($n125 == 0xbfa00000) { $reverse_byte_native_floats = 0; }
	else
	{
		printf STDERR "unknown native float format: -1.25 == 0x%x\n", $n125;
	}
}

sub reverse_bytes
{
	my($buf, $numsize) = @_;
	my(@buf_bytes) = split(//, $buf);
	my $out = '';
	my $i = 0;
	unless(scalar(@buf_bytes) % $numsize == 0)
	{
		print STDERR "internal misalignment error $numsize\n";
		return undef;
	}
	while(@buf_bytes)
	{
		$out .= reverse(splice(@buf_bytes, 0, $numsize));
	}
	return $out;
}

sub pack_float
{
	my(@nums) = @_;
	my $buf = pack('f*', @nums);
	return $reverse_byte_native_floats != $reverse_float_bytes ? reverse_bytes($buf, 4) : $buf;
}

sub pack_double
{
	my(@nums) = @_;
	my $buf = pack('d*', @nums);
	$buf = $reverse_byte_native_floats != $reverse_float_bytes ? reverse_bytes($buf, 8) : $buf;
	if($reverse_double_ints)
	{ $buf = reverse_parts($buf, 4, 2); }
	return $buf;
}

sub unpack_float
{
	my($buf) = @_;
	if($reverse_byte_native_floats != $reverse_float_bytes) { $buf = reverse_bytes($buf, 4); }
	return unpack('f*', $buf);
}

sub unpack_double
{
	my($buf) = @_;
	if($reverse_byte_floats != $f32_reverse_bytes) { $buf = reverse_bytes($buf, 8); }
	if($reverse_double_ints) { $buf = reverse_parts($buf, 4, 2); }
	return unpack('d*', $buf);
}

sub read_bits
{
	my($fh, $sizebits) = @_;

	my($buf) = '';
	my($readsizebits) = $sizebits - length($bitbufin);
	my($readsize) = POSIX::ceil($readsizebits / 8);
	if($readsizebits > 0) {
		return undef unless(defined(read(INFILE, $buf, $readsize)));
	}
	if($bitbufin ne '' or $readsizebits % 8)
	{
		$bitbufin .= unpack("B*", $buf);
		my $databits = substr ($bitbufin, 0, $sizebits, '');

		$buf =  pack('B*', $databits);
	}
	return $buf;
}

sub write_bits
{
	my( $fh, $bufref, $sizebits) = @_;

	# truncate or expand to fit
	my($datasize) = POSIX::ceil($sizebits / 8);
	unless(defined($bufref) and length($$bufref) == $datasize)
	{
		my $buf = pack("a$datasize", $$bufref);
		$bufref = \$buf;
	}
	if( $bitbufout ne '' or $sizebits % 8)
	{
		$bitbufout .= unpack("B$sizebits", $$bufref);
		$datasize = int(length($bitbufout) / 8);
		return unless($datasize);

		my($data) = pack('B*',
		substr($bitbufout, 0, $datasize * 8, ''));
		$bufref = \$data;
	}
	my $writelen = length($$bufref);
	print "error: invalid write datalen: $writelen != $datasize\n"
		unless($writelen == $datasize);
	print $fh $$bufref;
}

# splits a string up by spaces or as enclosed by quotes
sub split_strings
{
	my($s) = @_;
	my(@out);
	while($s ne '' &&
		(
		$s =~ m/^\'([^\']*)\'(\s+|$)/ or
		$s =~ m/^\"([^\"]*)\"(\s+|$)/ or
		$s =~ m/^(\S*)(\s+|$)/ ) )
	{
		push(@out, $1);
		$s = $';
	}
	return undef if($s ne "");
	return @out;
}

sub parse_translation
{
	my($lines) = @_;
	my(%translation, %reverse_translation);
	for my $line (split(/\s*\n\s*/ms, $lines))
	{
		my($old, $new) = split_strings($line);
		$old = hex($old) if($old =~ /^0x/);
		$new = hex($new) if($old =~ /^0x/);
		next if(! defined($old));
		next if($old eq "" and $new eq "");
		$translation{$old} = $new;
		$reverse_translation{$new} = $old;
	}
	return(\%translation, \%reverse_translation);
}

sub translate
{
	my($translation, @l) = @_;
	my(@out) = ();
	foreach my $a (@l)
	{
		my $t = $translation->{$t};
		push(@out, defined($translation->{$a}) ?
			$translation->{$a} : $a);
	}
	return @out;
}

my $bit_count = 0;
#use strict;

my($fmtfile, $infile, $outfile) = @ARGV;

unless(defined($outfile))
{
	print "usage: $0 BFMT BINFILE XMLFILE\n";
	print "usage: $0 BFMT XMLFILE BINFILE\n";
	exit(0);
}
local %structs;
local %struct_fields;
my(%primative_sizebits);
my(%primative_fromraw);
my(%primative_toraw);
my(%primative_tostring);
my(%primative_fromstring);

open(FMT, $fmtfile);
local $/ = undef;
my($text) = <FMT>;
close(FMT);

$text =~ s:\/\/.*(?=$)::gm;
$text =~ s:#.*(?=$)::gm;

$primative_sizebits{"UI8"} = 8;
$primative_sizebits{"CHAR"} =  8;
$primative_sizebits{"UUDATA"} = 8;
$primative_sizebits{"HEXDATA"} = 8;
$primative_sizebits{"SKIPBYTE"} = 8;

$primative_sizebits{"BITVECTOR"} = 1;
$primative_sizebits{"BITBITS"} = 1;
$primative_sizebits{"HEXBITS"} = 1;
$primative_sizebits{"UB"} = 1;
$primative_sizebits{"SB"} = 1;
$primative_sizebits{"SKIPBITS"} = 1;

$primative_sizebits{"UI16"} = 16;
$primative_sizebits{"UF16"} = 16;
$primative_sizebits{"INT24"} = 24;
$primative_sizebits{"UI32"} = 32;
$primative_sizebits{"F32"} = 32;
$primative_sizebits{"F64"} = 64;

sub primative_read_CSTRING
{
	my($fh, $count) = @_;
	my($outbuf) = "";
	while($count--)
	{
#print "CSTRING r$count\n";
		my($c);
		do
		{
			last unless(read($fh, $c, 1));
			$outbuf .= $c;
		}
		while($c ne "\0");
	}
#	print "CSTRING out: $outbuf\n";
	return $outbuf;
}
$primative_read{"CSTRING"} = \&primative_read_CSTRING;

sub primative_fromraw_CHAR
{
   my($bufref, $n) = @_;
   return $bufref;
}
$primative_fromraw{"BITVECTOR"} = \&primative_fromraw_CHAR;
$primative_fromraw{"BITBITS"} = \&primative_fromraw_CHAR;
$primative_fromraw{"HEXBITS"} = \&primative_fromraw_CHAR;
$primative_fromraw{"UUDATA"} = \&primative_fromraw_CHAR;
$primative_fromraw{"CHAR"} = \&primative_fromraw_CHAR;

# store UB as padded UI32's in memory
sub primative_fromraw_UB
{
	my($bufref, $n) = @_;
	my($bits) = unpack("B$n", $$bufref);
	my($align) = 32 - ( $n % 32);
	$align = 0 if($align == 32);
	my($prebits) = '';
	while($align--) { $prebits .= '0'}

	my(@bufout) = unpack("${uib32_pack}*", pack("B*", $prebits . $bits));
	return \@bufout;
}
$primative_fromraw{"UB"} = \&primative_fromraw_UB;

sub unpack_signed_ints
{
	my($form, $data) = @_;
	my(@out) = unpack($form, $data);
	my(@out2);
	my($out);
	while( defined($out = shift(@out)))
	{
		if($out >= 0x80000000) { $out -= 0x80000000; $out -= 0x80000000; }
		push(@out2, $out);
	} 
	return @out2;
}

sub pack_signed_ints
{
	my($form, @adata) = @_;
	my($out) = "";
	for my $data (@adata)
	{
		if($data < 0) { $data += 0x80000000; $data += 0x80000000 }
		$out .= pack("${form}*",$data);
	}

	return $out;
}

# store SB as padded UI32's in memory
sub primative_fromraw_SB
{
	my($bufref, $n) = @_;
	my($bits) = unpack("B$n", $$bufref);
	my($align) = 32 - ( $n % 32);
	$align = 0 if($align == 32);
	my($prebits) = '';
	my($fillbit) = substr($bits, 0, 1);
	while($align--) { $prebits .= $fillbit}

	my(@bufout) = unpack_signed_ints("${uib32_pack}*", pack("B*", $prebits . $bits));
	return \@bufout;
}
$primative_fromraw{"SB"} = \&primative_fromraw_SB;

sub primative_fromraw_HEXDATA
{
	my($bufref) = @_;
#	return undef if($$bufref =~ m:^\0*$:); #don't store zero data
	return $bufref;
}
$primative_fromraw{"HEXDATA"} = \&primative_fromraw_HEXDATA;

sub primative_fromraw_SKIPBITS
{
   my($bufref) = @_;
#print "d " . length($$bufref) . "\n";;
   print "non-zero skip\n" if($$bufref =~ /[^\0]/);
   return undef;
}
$primative_fromraw{"SKIPBITS"} = \&primative_fromraw_SKIPBITS;
$primative_fromraw{"SKIPBYTE"} = \&primative_fromraw_SKIPBITS;

sub primative_toraw_CHAR
{
   my($bufref) = @_;
   return $bufref;
}
$primative_toraw{"BITVECTOR"} = \&primative_toraw_CHAR;
$primative_toraw{"BITBITS"} = \&primative_toraw_CHAR;
$primative_toraw{"HEXBITS"} = \&primative_toraw_CHAR;
$primative_toraw{"HEXDATA"} = \&primative_toraw_CHAR;
$primative_toraw{"UUDATA"} = \&primative_toraw_CHAR;
$primative_toraw{"CHAR"} = \&primative_toraw_CHAR;

sub primative_fromraw_CSTRING
{
	my($bufref) = @_;
	my(@s) = split(/\x00/, $$bufref);
	return \@s;
}
$primative_fromraw{"CSTRING"} = \&primative_fromraw_CSTRING;

sub primative_toraw_CSTRING
{
	my($bufref, $count) = @_;
	my($sbuf) = $count ? ( join("\0", @$bufref) . "\0" ) : '';
	return \$sbuf;
}
$primative_toraw{"CSTRING"} = \&primative_toraw_CSTRING;

# store UB as integers in memory.
sub primative_toraw_UB
{
	my($bufref, $n) = @_;
	my($bits) = unpack("B*", pack("${uib32_pack}*", @$bufref));
	my($align) = 32 - ($n % 32);
	$align = 0 if($align == 32);
	my($buf) = pack("B*", substr($bits, $align));
	return \$buf;
}
$primative_toraw{"UB"} = \&primative_toraw_UB;

sub primative_toraw_SB
{
	my($bufref, $n) = @_;
	my($bits) = unpack("B*", pack_signed_ints(${uib32_pack}, @$bufref));
	my($align) = 32 - ($n % 32);
	$align = 0 if($align == 32);
	my($buf) = pack("B*", substr($bits, $align));
	return \$buf;
}
$primative_toraw{"SB"} = \&primative_toraw_SB;

sub primative_toraw_SKIPBITS
{
	return undef;
}
$primative_toraw{"SKIPBITS"} = \&primative_toraw_SKIPBITS;
$primative_toraw{"SKIPBYTE"} = \&primative_toraw_SKIPBITS;

sub primative_fromraw_F64
{
	my($bufref) = @_;
	my(@bufout) = unpack_double($$bufref);
	return \@bufout;
}
$primative_fromraw{"F64"} = \&primative_fromraw_F64;

sub primative_toraw_F64
{
	my($bufref) = @_;
	my($bufout) = pack_double(@$bufref);
	return \$bufout;
}
$primative_toraw{"F64"} = \&primative_toraw_F64;

sub primative_fromraw_F32
{
	my($bufref) = @_;
	my(@bufout) = unpack_float($$bufref);
	return \@bufout;
}
$primative_fromraw{"F32"} = \&primative_fromraw_F32;

sub primative_toraw_F32
{
	my($bufref) = @_;
	my($bufout) = pack_float(@$bufref);
	return \$bufout;
}
$primative_toraw{"F32"} = \&primative_toraw_F32;

sub primative_fromraw_UI32
{
   my($bufref) = @_;
   my(@bufout) = unpack("${ui32_pack}*", $$bufref);
   return \@bufout;
}
$primative_fromraw{"UI32"} = \&primative_fromraw_UI32;

sub primative_fromraw_UI8
{
   my($bufref) = @_;
   my(@bufout) = unpack('C*', $$bufref);
   return \@bufout;
}
$primative_fromraw{"UI8"} = \&primative_fromraw_UI8;

sub primative_toraw_UI8
{
   my($bufref) = @_;
   my($bufout) = pack('C*', @$bufref);
   return \$bufout;
}
$primative_toraw{"UI8"} = \&primative_toraw_UI8;

sub ui16tofixed
{
	my(@values) = @_;
	my(@out) = ();
	for my $value (@values)
	{
		my($v1) = $value >> 8;
		my($v2) = $value & 0xff;
		push(@out, $v1 + $v2/0x100);
	}
	return @out;
}

sub fixedtoui16
{
	my(@values) = @_;
	my(@out) = ();
	for my $value (@values)
	{
		my($v1) = int($value);
		my($v2) = int(($value - $v1) * 0x100);
		push(@out, ($v1 << 8) | $v2);
	}
	return @out;
}

sub primative_fromraw_UF16
{
	my($bufref) = @_;
	my(@bufout) = ui16tofixed(unpack("${ui16_pack}*", $$bufref));
	return \@bufout;
}
$primative_fromraw{"UF16"} = \&primative_fromraw_UF16;

sub primative_toraw_UF16
{
   my($bufref) = @_;
   my($bufout) = pack("${ui16_pack}*", fixedtoui16(@$bufref));
   return \$bufout;
}
$primative_toraw{"UF16"} = \&primative_toraw_UF16;

sub primative_fromraw_UI16
{
   my($bufref) = @_;
   my(@bufout) = unpack("${ui16_pack}*", $$bufref);
   return \@bufout;
}
$primative_fromraw{"UI16"} = \&primative_fromraw_UI16;

sub primative_toraw_UI16
{
   my($bufref) = @_;
   my($bufout) = pack("${ui16_pack}*", @$bufref);
   return \$bufout;
}
$primative_toraw{"UI16"} = \&primative_toraw_UI16;

# pad INT24 to UI32's
sub primative_fromraw_INT24
{
	my($bufref) = @_;
	my(@data) = unpack('C*', $$bufref);
	my(@bufout);
	while(@data)
	{
		my(@n) = splice(@data, 0, 3);
		unshift(@n, 0); # add high byte
		push(@bufout, unpack("N", pack("C4", @n)));
	}
	return \@bufout;
}
$primative_fromraw{"INT24"} = \&primative_fromraw_INT24;
	
sub primative_toraw_INT24
{
	my($bufref) = @_;

	my(@data) = @$bufref;

	my(@bufout);
	while(@data)
	{
		my(@n) = unpack("C4", pack("N", shift(@data)));
		shift(@n); # remove high byte
		push(@bufout, @n);
	}
	
	my($buf) = pack('C*', @bufout);
	return \$buf;
}
$primative_toraw{"INT24"} = \&primative_toraw_INT24;


sub primative_toraw_UI32
{
   my($bufref) = @_;
   my($bufout) = pack("${ui32_pack}*", @$bufref);
   return \$bufout;
}
$primative_toraw{"UI32"} = \&primative_toraw_UI32;

sub primative_tostring_EVAL
{
	my($dataref) = @_;
	return $dataref;
}
$primative_tostring{"EVAL"} = \&primative_tostring_EVAL;

sub primative_fromstring_EVAL
{
	my($str) = @_;
	return $str;
}
$primative_fromstring{"EVAL"} = \&primative_fromstring_EVAL;

sub primative_tostring_HEXDATA
{
   my($bufref) = @_;
   
   return unpack("H*", $$bufref);
   
}
$primative_tostring{"HEXDATA"} = \&primative_tostring_HEXDATA;

sub primative_tostring_UUDATA
{
   my($bufref) = @_;

   my $s = pack("u", $$bufref);
   if(length($s) > 60)
   {
      $s = "\n" . $s;
   }
   else
   {
     $s =~ s:\n$::;
   }
   return $s;
}
$primative_tostring{"UUDATA"} = \&primative_tostring_UUDATA;

sub primative_tostring_BITVECTOR
{
	my($bufref, $count, $trans) = @_;
	my(@setbits);
	my($i) = $count - 1;
	for my $b (split(//, unpack("B$count", $$bufref)))
	{
		push(@setbits,$i) if($b);
		$i--;
	}
	return join(',', translate($trans,@setbits));
}
$primative_tostring{"BITVECTOR"} = \&primative_tostring_BITVECTOR;

sub primative_fromstring_BITVECTOR
{
	my($instr, $count, $rtrans) = @_;
	my(%setbits);
	for my $n (translate($rtrans,split(/,/, $instr)))
	{
		$setbits{$n} = 1;
	}
	my $bits = "";
	for (my $i = $count -1; $i >= 0; $i--)
	{
		$bits .= ($setbits{$i}) ? 1 : 0;
	}
	my $buf = pack("B$count", $bits);
	return \$buf;
}
$primative_fromstring{"BITVECTOR"} = \&primative_fromstring_BITVECTOR;

sub primative_tostring_SKIPBITS
{
	return undef;
}
$primative_tostring{"SKIPBITS"} = \&primative_tostring_SKIPBITS;
$primative_tostring{"SKIPBYTE"} = \&primative_tostring_SKIPBITS;

sub primative_fromstring_SKIPBITS
{
	return undef;
}
$primative_fromstring{"SKIPBITS"} = \&primative_fromstring_SKIPBITS;
$primative_fromstring{"SKIPBYTE"} = \&primative_fromstring_SKIPBITS;

sub primative_tostring_BITBITS
{
	my($bufref, $n) = @_;
	return unpack("B$n", $$bufref);
}
$primative_tostring{"BITBITS"} = \&primative_tostring_BITBITS;

sub primative_fromstring_BITBITS
{
	my($instr, $n) = @_;
	my $buf = pack("B*", $instr);
	return \$buf;
}
$primative_fromstring{"BITBITS"} = \&primative_fromstring_BITBITS;

sub primative_tostring_HEXBITS
{
	my($bufref, $n) = @_;

	my($bits) = unpack("B$n", $$bufref);
	my($align) = 8 - ( $n % 8);
	$align = 0 if($align == 8);
	my($prebits) = '';
	while($align--) { $prebits .= '0'}
	
	my $str = unpack("H*", pack("B*", $prebits . $bits));
	
	# strip off first 4bit nibble if needed
	#$str = substr($str, -1, 1, '') if(length($prebits) >= 4);
	chop($str) if(length($prebits) >= 4);
	return $str;
}
$primative_tostring{"HEXBITS"} = \&primative_tostring_HEXBITS;

sub primative_fromstring_HEXBITS
{
	my($instr, $n) = @_;
	my $bits = unpack("B*", pack("H*", $instr));
	my($align) = 8 - ($n % 8);
	$align = 0 if($align == 8);
	$bits = substr($bits, $align);
	my($buf) = pack("B*", $bits);
	return \$buf;
}
$primative_fromstring{"HEXBITS"} = \&primative_fromstring_HEXBITS;

sub primative_fromstring_HEXDATA
{
   my($instr) = @_;
   my($buf);
my $l = length($instr);

   $buf = pack("H*", $instr);
   return \$buf;
}
$primative_fromstring{"HEXDATA"} = \&primative_fromstring_HEXDATA;

sub primative_fromstring_UUDATA
{
   my($instr) = @_;
   my($buf);
   $instr =~ s:^\n::;

   $buf = unpack("u", $instr);
   return \$buf;
}
$primative_fromstring{"UUDATA"} = \&primative_fromstring_UUDATA;

sub primative_tostring_CHAR
{
	my($bufref, $n, $trans) = @_;
	my($buf) = unpack("Z$n", $$bufref);
	return (translate($trans, $buf))[0];
}
$primative_tostring{"CHAR"} = \&primative_tostring_CHAR;

sub primative_fromstring_CHAR
{
	my($instr, $n, $rtrans) = @_;
	($instr) = translate($rtrans, $instr) if(defined($rtrans));
	return \$instr if((!defined($n)) ||
		length($instr) == $n);
	my($buf) = pack("a$n", $instr);
	return \$buf;
}
$primative_fromstring{"CHAR"} = \&primative_fromstring_CHAR;

sub primative_tostring_UI8
{
   my($bufref,$count,$trans) = @_;
   return (join ",", translate($trans,@$bufref));
}
$primative_tostring{"UI8"} = \&primative_tostring_UI8;
$primative_tostring{"UF16"} = \&primative_tostring_UI8;
$primative_tostring{"UI16"} = \&primative_tostring_UI8;
$primative_tostring{"INT24"} = \&primative_tostring_UI8;
$primative_tostring{"UI32"} = \&primative_tostring_UI8;
$primative_tostring{"F32"} = \&primative_tostring_UI8;
$primative_tostring{"F64"} = \&primative_tostring_UI8;
$primative_tostring{"UB"} = \&primative_tostring_UI8;
$primative_tostring{"SB"} = \&primative_tostring_UI8;
$primative_tostring{"CSTRING"} = \&primative_tostring_UI8;

sub primative_fromstring_UI8
{
	my($instr,$count,$rtrans) = @_;
	my @out = translate($rtrans,split(',', $instr));
	return \@out;
}
$primative_fromstring{"UI8"} = \&primative_fromstring_UI8;
$primative_fromstring{"UI16"} = \&primative_fromstring_UI8;
$primative_fromstring{"UF16"} = \&primative_fromstring_UI8;
$primative_fromstring{"INT24"} = \&primative_fromstring_UI8;
$primative_fromstring{"UI32"} = \&primative_fromstring_UI8;
$primative_fromstring{"F32"} = \&primative_fromstring_UI8;
$primative_fromstring{"F64"} = \&primative_fromstring_UI8;
$primative_fromstring{"UB"} = \&primative_fromstring_UI8;
$primative_fromstring{"SB"} = \&primative_fromstring_UI8;
$primative_fromstring{"CSTRING"} = \&primative_fromstring_UI8;

while(1)
{
#if($text =~ m%^\s*([\w]+\*?):\s*\n\s*([^:]*)\s*\n:\n%s )
if($text =~ m%^\s*([\w]+\*?):\s*\n\s*(.*?):\n%s )
{
	my($structname) = $1;
	my($fields) = $2;
	print "struct: $structname\n" if($debug);
	@{$structs{$structname}} = ();

	my $i = 1;
        for my $field (split(/\s*\n\s*/ms, $fields))
        {
		next if $field eq "";
		unless($field =~ m:^
			(\[([^\]]*)\]\s*)? # [$2]
			(([\w{}]+)(\s*\[([^\[\]]+)\])?\@)? # $4[$6]@
			([\w{}]+)(\s*\[([^\[\]]*)\])? # $7[$9]
			(\s+\<([\w{}]+)\>)? # <$11>
			(\s+((\w+)\@)?(\w+))? # 14@15
			(\s=\s*(.*))? # =17
			$:x) { print "RRR $field\n"; }
		my($offset, $ptype, $pcount, $stype, $count, $trans, $pname, $name, $value) = ($2, $4, $6, $7, $9, $11, $14, $15, $17);
		print '($offset, $ptype, $pcount, $stype, $count, $trans, $pname, $name, $value) = ($2, $4, $6, $7, $9, $11, $14, $15, $17) = ' . "$offset, $ptype, $pcount, $stype, $count, $trans, $pname, $name, $value\n" if ($debug);
                $count = 1 unless(defined($count));
		undef $count if($count eq '');
		$name = $stype . $i unless(defined($name));
		if(defined($ptype))
		{
			$pcount = 1 unless(defined($pcount));
			my $fields = [ $stype, $count, $trans, $value, $offset, $ptype, $pname, $pcount ];
			push(@{$structs{$structname}}, [ $name, $fields ]);
			$struct_fields{$structname}->{$name} = $fields;
			# when reading xml, we need the ptypes as fields too
			$struct_fields{$structname}->{$pname} = [ $ptype, $pcount ];
		}
		else
		{
			my $fields = [ $stype, $count, $trans, $value, $offset ];
			push(@{$structs{$structname}}, [ $name, $fields ]);
			$struct_fields{$structname}->{$name} = $fields;
		}
		$i++;
	}
	$text = $'; #indentfix->';
}
elsif($text =~ m%^\s*([\w\d]*)=$([^=]+)^=$%ms )
{
	if($1 eq '')
	{
		($file_settings) = parse_translation($2);
	}
	else
	{
		($translations{$1}, $reverse_translations{$1}) = parse_translation($2);
	}
	$text = $';
}
else { last; }
}

for my $structname (keys %structs)
{
	print "struct $structname\n" if ($debug);
        for my $name_fields (@{$structs{$structname}})
	{
		my($name, $fields) = @$name_fields;
		my($stype, $count) = @$fields;
		print "fields: stype $stype, name $name, size $count\n" if($debug);
	}
}

if($file_settings->{"BYTE_ORDER"} eq 'vax')
{
	$ui32_pack = 'V';
	$ui16_pack = 'v';
	$f32_reverse_bytes = 1;
	$uib32_pack = 'V';
}
elsif($file_settings->{"BYTE_ORDER"} eq 'vax_swf')
{
	$ui32_pack = 'V';
	$ui16_pack = 'v';
	$f32_reverse_bytes = 1;
	$f32_reverse_ints = 1;
	$uib32_pack = 'N';
}
elsif($file_settings->{"BYTE_ORDER"} eq 'vax_except_bits')
{
	$ui32_pack = 'V';
	$ui16_pack = 'v';
	$f32_reverse_bytes = 1;
	$uib32_pack = 'N';
}


if($infile =~ m:\.xml$:)
{
print "xml to raw\n";
open(INFILE, $infile);
open(OUTFILE, ">$outfile");
my $mainref = struct_read_xml("MAIN");
#struct_write_xml("MAIN", "", $mainref); 
struct_write("MAIN", $mainref); 
close(INFILE);
if(defined($file_settings->{"SECTOR_SIZE"}))
{
	seek(OUTFILE,0,2);
	my($remain) = tell(OUTFILE) % $file_settings->{"SECTOR_SIZE"};
	$remain = 2048 - $remain if($remain);
	my($buf) = pack("Z$remain", "");
	print OUTFILE $buf;
}
close(OUTFILE);
}
elsif($outfile =~ m:\.xml$:)
{
print "raw to xml\n";
open(INFILE, $infile);
open(OUTFILE, ">$outfile");
my $mainref = struct_read("MAIN");
struct_write_xml("MAIN", "", $mainref); 
close(INFILE);
close(OUTFILE);
}
else
{
open(INFILE, $infile);
open(OUTFILE, ">$outfile");
my $mainref = struct_read("MAIN");
struct_write("MAIN", $mainref); 
close(INFILE);
close(OUTFILE);
   print "unknown conversion\n";
}

sub struct_read
{
	my($stype, $parent_structs, $struct_start, $struct_end, $array_last) = @_;
	printf "read struct: %x %x (%d)\n", tell(INFILE), tell(INFILE) - $struct_start, tell(INFILE) - $struct_start if($debug);
	my(%this_struct);
#	unless(defined($struct_start))
#	{
#		$struct_start = tell(INFILE);
#	}

	unless(defined($parent_structs))
	{
		$parent_structs = [];
	}

	unless(defined($array_last))
	{
		my $this_array_last = 0;
		$array_last = \$this_array_last;
	}

	for my $name_fields (@{$structs{$stype}})
	{
		my($fname, $fields) = @$name_fields;
		my($ftype, $fcount, $ftrans, $fvalue, $foffset, $fptype, $fpname, $fpcount) = @$fields;
		my($fdata);
		my($fcountset, $fpcountset);

		$ftype = expand_struct_type($struct_fields{$stype}, \%this_struct, $ftype);
		$ftrans = expand_struct_type($struct_fields{$stype}, \%this_struct, $ftrans);
			

		my($pos);
		
		# empty fcount means remaining bits or everything
		if((!defined($fcount)) || $fcount eq '')
		{
			my($sizebits) = $primative_sizebits{$ftype};
			$sizebits = struct_size($ftype) unless(defined($sizebits));
			if($sizebits == 1)
			{
				$fcount = length($bitbufin);
			}
			else
			{
				my $pos = tell(INFILE);
				my $endpos  = $struct_end;
				unless(defined($endpos))
				{
					seek(INFILE, 0, 2);
					$endpos = tell(INFILE);
					seek(INFILE, $pos, 0);
				}
				if(defined($sizebits))
				{
				$fcount = int (($endpos-$pos) * 8/$sizebits);
				}
				else
				{ $fcount = -1; }
			}
		}
		else
		{
			($fcount, $fcountset) = &struct_expression($struct_fields{$stype}, \%this_struct, $fcount, $parent_structs);
			#next unless($fcount);
			#print "count: $fcount, $fcountset\n";
		}
		if(defined($fcount) and $fcount == 0)
		{
			@{$this_struct{$fname}} = (undef, 0, 0);
			next;
		}
print "pos: " . tell(INFILE) . "\n" if($debug);
print "read: $stype: $ftype, name=$fname, count = $fcount, offset=$foffset LAST $array_last\n" if($debug);
		$fcountset = $fcount unless(defined($fcountset) and
			$fcountset <= $fcount);
		#print "pcount in: $fpcount\n";

		($fpcount, $fpcountset) = &struct_expression($struct_fields{$stype}, \%this_struct, $fpcount, $server_struct);
		#print "pcount: $fpcount\n";
		$fpcountset = $fpcount unless(defined($fpcountset) 
			and $fpcountset <= $fpcount);
#print "fff: $stype: $ftype, $fname, fsc = $fcountset, fc = $fcount, $foffset\n";
		if(defined($foffset))
		{
			($foffset) = &struct_expression($struct_fields{$stype}, \%this_struct, $foffset, $parent_structs, $struct_start);
			next unless($foffset);
			$pos = tell(INFILE);

			my $r = seek(\*INFILE, $struct_start+ $foffset,0);
			print "seek error: $!\n" unless($r);
			print "before $ftype $fname\n" if($r > 1);
			
		}
printf ("off: ($ftype) %x %x + %d\n", tell(INFILE), tell(INFILE) - $struct_start, length($bitbufin)) if($debug);
		#$fvalue = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs)
		#	if(defined($fvalue));
		if(defined($primative_sizebits{$ftype}))
		{
			my $buf = read_bits(\*INFILE, $fcount * 
				$primative_sizebits{$ftype});
			return undef unless (defined($buf) and length($buf) > 0);

			$fdata = &{$primative_fromraw{$ftype}}(\$buf, $fcountset);

			print "fdata value : ", fdata_value($fdata) , "\n" if($debug);
# assertion not ready
#			print "assertion failed: ", fdata_value($fdata), " != $fvalue\n"
		#		if(defined($fvalue) && ! fdata_equals($fdata, $fvalue));
		}
		elsif(defined($primative_read{$ftype}))
		{
			my $buf = &{$primative_read{$ftype}}(\*INFILE, $fcount);
			$fdata = &{$primative_fromraw{$ftype}}(\$buf, $fcountset);
#			print "assertion failed: ", fdata_value($fdata), " != $fvalue\n"
#				if(defined($fvalue) && ! fdata_equals($fdata, $fvalue));
		}
		elsif(defined($structs{$ftype}))
		{
			#print "struct in: $ftype ($fcountset of $fcount)\n";
			my $array_last = 0;
			my $i;

			push(@$parent_structs, \%this_struct);
			for ($i = 0 ; $fcountset < 0 || $i < $fcountset; $i++)
			{
				my $s = struct_read($ftype, $parent_structs,$struct_start, $struct_end, $array_last);
				last unless(defined($s));
				push(@{$fdata}, $s);

				if(defined($array_last) and ( $$array_last == 1 or $$array_last eq $ftype))
				{
					$$array_last = 0;
					last;
				}
				last if(defined($struct_end) and tell(INFILE) >= $struct_end);
			}
			pop(@$parent_structs);

			my $countunset = $fcount - $fcountset;
			print "reads: $ftype $fcountset,$fcount\n" if($debug);
			read_bits(\*INFILE, $countunset *
                                struct_size($ftype))
					if($countunset);
		}
# TODO: should evaluate all at end of struct. put in function shared by struct_read_xml
		elsif($ftype eq "EVAL")
		{
			($fvalue) = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs);
			$fdata = $fvalue;
		}
		else
		{
			print STDERR "unknown stype: $ftype\n";
		}

		if($ftype eq "EVAL")
		{
			if($fname eq "DATA_END")
			{
				$struct_end = tell(INFILE) + $fdata;
				next;
			}
			if($fname eq "OFFSET_START")
			{
				$struct_start = tell(INFILE);
				next;
			}
			if($fname eq "ARRAY_LAST" or $fname eq "LAST")
			{
				$$array_last = $fdata if(defined($array_last));
				next;
			}
			if($fname eq "BREAK")
			{
				if(defined($array_last))
				{
					$$array_last = $fdata;
					if($fdata) { last; }
					else { next; }
				}
			}
		}

		#print "set struct $fname ($fcountset)\n";
			print "fdata x value : ", fdata_value($fdata) , "\n" if($debug);
		@{$this_struct{$fname}} = ($fdata, $fcountset, $fcount)
			if(defined($fdata));
		my $fpdata;
		
		# read in structs pointed to
		if(defined($fptype) and ref $fdata eq "ARRAY")
		{
			#print "POINTER struct in: $fptype\n";
			my $prevpos = tell(INFILE);
			#print "POINTER read $fcount by $fpcount\n";
			for (my $i = 0 ; $i < $fcount; $i++)
			{
				next unless($fdata->[$i]);
				my $newpos = $struct_start + $fdata->[$i];
				#print "seek from $prevpos to $newpos\n";
				print "seek error: $!\n"
				unless(seek(INFILE, $newpos, 0));

			        push(@$parent_structs, \%this_struct);
				for (my $pi = 0 ; $pi < $fpcount; $pi++)
				{
					push(@$fpdata ,
						struct_read($fptype, $parent_structs, $struct_start, $struct_end, $array_last));
				}
				pop(@$parent_structs);
				@{$this_struct{$fpname}} = ($fpdata, $fpcountset, $fpcount)
				if(defined($fpdata));
			}
			seek(INFILE, $prevpos, 0);
		}
#		seek(INFILE, $pos, 0 ) if(defined($pos));
	}

	#remove hidden values (_evals or _values that match evaluation)
	for my $fname (keys %{$struct_fields{$stype}})
	{
	#print STDERR "$stype: $fname\n";
		my $fieldref = $struct_fields{$stype}->{$fname};
		my($ftype, $fcount, $ftrans, $fvalue) = @$fieldref;

		next unless ($fname =~ /^_/);
		undef $this_struct{$fname};
		next;

		if($ftype eq "EVAL")
		{
			undef $this_struct{$fname};
		}
		elsif(defined($fvalue))
		{
			my $fvalue0 = $fvalue;
			($fvalue) = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs);
			my($fdata) = $this_struct{$fname}->[0];
			my $fdata_value = fdata_value($fdata);
			if($fdata_value eq $fvalue)
			{
				#print STDERR "data eq value : $stype, $fname, $fdata_value, $fvalue\n";
				#@{$this_struct{$fname}} = (undef, 0, 0);
				undef $this_struct{$fname};
			}
			else
			{
				print STDERR "data ne value : $stype, $fname, $fdata_value, $fvalue ($fvalue0)\n";
			}
		}
	}
print "read-out: $stype: $ftype, name=$fname LAST $array_last\n" if($debug);
	return \%this_struct;
}

sub expand_struct_type
{
	my($fieldsref, $structref, $ftype) = @_;

	while($ftype =~ m/{([^{}]+)}/)
	{
		my $othername = $1;
		my ($before, $after) = ($`,$');
		$othername = "*" unless(defined($structref->{$othername}));
		last unless(defined($structref->{$othername}));
		my $otherfields = $fieldsref->{$othername};
		last unless(defined($otherfields));
		my($othertype, $othercount, $othertrans) = @$otherfields;
		my ($data, $datacount) = @{$structref->{$othername}};
		last unless(defined($data));
		last unless(defined($primative_tostring{$othertype}));
		my $s = &{$primative_tostring{$othertype}}($data, $othercount, $translations{$othertrans});
#x
#		$s = $translations{$othertrans}->{$s}
#		if(defined($othertrans) and defined($translations{$othertrans}) and defined($translations{$othertrans}->{$s}));
		$s = "*" unless(defined($structs{$before.$s.$after}) or defined($translations{$before.$s.$after}));
		$ftype = $before . $s . $after;
	}
	return $ftype;
}

sub expression_value
{
	my($value) = @_;
	
	return "()" unless(defined($value));
	return "''" if($value eq '');
	return "'$value'" if($value =~ m:[^\d]:);
	return $value;
}

sub data_expression_value
{
	my($data) = @_;
	if(ref($data) eq 'ARRAY')
	{
	#	return $data->[0];
		my $size = @{$data};
		# return last element
		return $size ? expression_value($data->[$size -1]) : 0;
	}
	elsif(ref $data)
	{
		#print "dsd $1\n";
		#print ref $this_struct->{$1}->[0];
		#$buf2 .= $this_struct->{$1}->[0];
		return expression_value(${$data});
	}
	else
	{
		return expression_value($data);
	}
}

sub parent_data
{
	my($parent_structs, $name) = @_;
	my(@structs) = @$parent_structs;
	while(@structs)
	{
		my $struct = pop(@structs);
		return $struct->{$name}->[0] if(defined($struct->{$name}));
	}
	return undef;
}

sub parent_count
{
	my($parent_structs, $name) = @_;
	my(@structs) = @$parent_structs;
	while(@structs)
	{
		my $struct = pop(@structs);
		return $struct->{$name}->[1] if(defined($struct->{$name}));
	}
	return undef;
}

sub struct_expression
{
	my($fieldsref, $this_struct, $buf, $parent_structs, $struct_start) = @_;
	return undef unless(defined($buf));
	return ($buf) unless($buf =~ /\D/);
	my($buf2) = '';
	my $buf0 = $buf;
	while($buf =~ m:count\(([A-Za-z_]\w*)\):)
	{
		$buf = $'; #';#<-indent fix
		$buf2 .= $`;
		if(defined($this_struct->{$1}) )
		{
			#$buf2 .= $this_struct->{$1}->[1];
			$buf2 .= scalar(@{$this_struct->{$1}->[0]});
		}
		elsif(defined($fieldsref->{$1}))
		{
			$buf2 .= 0;
		}
		elsif(defined(my $count = parent_count($parent_structs,$1)))
		{
			$buf2 .= $count;
		}
		else
		{
			$buf2 .= "count($1)";
		}
	}
	while($buf =~ m:([A-Za-z_]\w*):)
	{
		$buf = $'; #';#<-indent fix
		$buf2 .= $`;
		if($1 eq "struct_start")
		{
			$buf2 .= $struct_start;
		}
		elsif(defined($this_struct->{$1}) )
		{
			$buf2 .= data_expression_value($this_struct->{$1}->[0]);
		}
		elsif(defined($fieldsref->{$1}))
		{
			$buf2 .= '';
		}
		elsif(defined(my $data = parent_data($parent_structs,$1)))
		{
			$buf2 .= data_expression_value($data);
		}
		else
		{
			$buf2 .= $1;
		}
	}
	$buf2 .= $buf;
	my (@rtn) = eval($buf2);
	return (@rtn);
	print STDERR "eval $buf0 => $buf2\n" if($@);
	$rtn[0] = 0 unless(scalar(@rtn) and $rtn[0] ne '');
	return @rtn;
}

sub string_to_data
{
	my($fieldsref, $structref, $fname, $fdata_value, $parent_structs) = @_;

	my($ftype, $fcount, $ftrans, $fvalue) = @{$fieldsref->{$fname}};

	$ftype = expand_struct_type($fieldsref, $structref, $ftype);
	$ftrans = expand_struct_type($fieldsref, $structref, $ftrans);

	#$fvalue = struct_expression($fieldsref, $structref, $fvalue, $parent_structs);
#	print "assertion failed: $fdata != $fvalue\n"
#	unless(fdata_equals($fdata, $fvalue));

	($fcount, $fcountset) = &struct_expression($fieldsref, $structref, $fcount, $parent_structs, $struct_start);
	$fcountset = $fcount unless(defined($fcountset) and
		$fcountset <= $fcount);
	#print "pcount in: $fpcount\n";

	if(defined($primative_fromstring{$ftype}))
	{
#x
#		if(defined($ftrans) and defined($reverse_translations{$ftrans}) and defined $reverse_translations{$ftrans}->{$fdata_value})
#		{
#			$fdata_value = $reverse_translations{$ftrans}->{$fdata_value};
#		}
				
		$fdata =
		&{$primative_fromstring{$ftype}}($fdata_value, $fcountset,$reverse_translations{$ftrans});
		#$fcountset = $fcount = scalar(@$fdata) unless(defined($fcountset) or ref $fdata ne "ARRAY");
		$fcountset = $fcount = ceil(length($$fdata)*8/$primative_sizebits{$ftype}) unless(defined($fcountset));
	}
	else
	{
		print STDERR "non primative paramater: $fname ($ftype)\n";
	}

	return ($fdata, $fcountset, $fcount);
}

sub struct_read_xml
{
	my($stype, $name, $params, $parent_structs) = @_;

	my $singletag = ($params =~ s:/$::g);

	my(%this_struct);

	while($params =~ /^\s*(\w+)\s*=\s*\"([^\"]*)\"\s*/)
	{
		my $param_name = $1;
		my $param_value = $2;
		$params = $';

		@{$this_struct{$param_name}} = string_to_data($struct_fields{$stype}, \%this_struct, $param_name, $param_value, $parent_structs);
#TODO check is struct_fields{stype} correct
	}

	#return \%this_struct if($singletag);
	

#	for my $name ( keys %{$struct_fields{$stype}} )
#	{
#		@{$this_struct{$name}} = (undef, 0, 0);
#	}

	unless(defined($parent_structs))
	{
		$parent_structs = [];
	}
	
	local $/ = '>';
	while((!$singletag) and defined(my $tag = <INFILE>))
	{
		last unless ($tag =~ m:\S:m);
		unless($tag =~ m:^\s*\<\s*([^\>\s]+)([^\>]+)*\>$:m)
		{
			print "$stype: did not get expected tag in $name: $tag\n";
			last;
		}
		my $fname = $1;
		my $params = $2;

		last if(defined($name) and $fname eq "/$name");
		if(defined($struct_fields{$stype}->{$fname}))
		{
			my $fieldref = $struct_fields{$stype}->{$fname};
			my($ftype, $fcount, $ftrans, $fvalue) = @$fieldref;
			my($fdata);
			# add sequential structure
			$fdata = $this_struct{$fname}->[0]
				if(defined($this_struct{$fname}));
			my($fcountset, $fpcountset);

			next if($ftype eq "EVAL"); # handled in write

			$ftype = expand_struct_type($struct_fields{$stype}, \%this_struct, $ftype);
			$ftrans = expand_struct_type($struct_fields{$stype}, \%this_struct, $ftrans);

#			if(defined($fvalue))
#			{	
#				$fvalue = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs);
#				print "assertion failed: $fdata != $fvalue\n"
#					unless(fdata_equals($fdata, $fvalue));
#			}

			($fcount, $fcountset) = &struct_expression($struct_fields{$stype}, \%this_struct, $fcount, $parent_structs, $struct_start);
			#next unless($fcount);
			$fcountset = $fcount unless(defined($fcountset) and
				$fcountset <= $fcount);
			#print "pcount in: $fpcount\n";
			($fpcount, $fpcountset) = &struct_expression($struct_fields{$stype}, \%this_struct, $fpcount, $parent_structs, $struct_start);
			$fpcountset = $fpcount unless(defined($fpcountset) 
				and $fpcountset <= $fpcount);
			
			if(defined($primative_fromstring{$ftype}))
			{
				local $/ = "</$fname>";
				my $data = <INFILE>;
				unless(defined($data))
				{
					print STDERR "incomplete field: $fname\n";
					last;
				}
				chomp $data;
#x
#				if(defined($ftrans) and defined($reverse_translations{$ftrans}) and defined $reverse_translations{$ftrans}->{$data})
#				{
#					$data = $reverse_translations{$ftrans}->{$data};
#				}
				
				$fdata =
				&{$primative_fromstring{$ftype}}($data, $fcountset, $reverse_translations{$ftrans});
				$fcountset = $fcount = ceil(length($$fdata)*8/$primative_sizebits{$ftype}) unless(defined($fcountset));
			}
			elsif(defined($structs{$ftype}))
			{
				push(@$parent_structs, \%this_struct);
				push(@$fdata, struct_read_xml($ftype, $fname, $params, $parent_structs));
				pop(@$parent_structs);
				$fcountset = $fcount = scalar(@$fdata) unless(defined($fcountset));
			}
			#elsif($ftype eq "EVAL") { next; }
			#elsif($ftype eq "EVAL")
			#{
			#	($fvalue) = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs);
			#	$fdata = $fvalue;
			#}
			@{$this_struct{$fname}} = ($fdata, $fcountset, $fcount);
			my $rr = \%this_struct;
			print "xmlin $rr $ftype $fdata $fname $fcount $fcountset\n" if ($debug);
		}
		else
		{
			print "no such field: $fname in $stype\n";
		}
	}

	# evaluate undefined EVALS
	for my $fname (keys %{$struct_fields{$stype}})
	{
		my $fieldref = $struct_fields{$stype}->{$fname};
		my($ftype, $fcount, $ftrans, $fvalue) = @$fieldref;
		my($fdata) = $this_struct{$fname}->[0];

		next unless($ftype eq "EVAL");
		next unless(defined($fvalue) and !defined($fdata));
		#print "un v $fname $fvalue\n" if($fname eq "_have_long_len");

		($fvalue) = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs);
		#print "un vv $fname $fvalue\n" if($fname eq "_have_long_len");
		#$this_struct{$fname}->[0] = $fvalue;
		@{$this_struct{$fname}} = ($fvalue, 1, 1);
	}

	# evaluate undefined data
	for my $fname (keys %{$struct_fields{$stype}})
	{
		my $fieldref = $struct_fields{$stype}->{$fname};
		my($ftype, $fcount, $ftrans, $fvalue) = @$fieldref;
		my($fdata) = $this_struct{$fname}->[0];

		next if($ftype eq "EVAL");
		next if(defined($fdata) or !defined($fvalue));

		($fvalue) = struct_expression($struct_fields{$stype}, \%this_struct, $fvalue, $parent_structs);
		next unless(defined($primative_fromstring{$ftype}));
		my($fdata) = &{$primative_fromstring{$ftype}}($fvalue);
		my $fcount = ref($fdata) eq "ARRAY" ? scalar(@$fdata) : 1;

		@{$this_struct{$fname}} = ($fdata, $fcount, $fcount);
	}

	# re-evaluate data counts. size may have changed from above evaluation
	for my $fname (keys %{$struct_fields{$stype}})
	{
		my $fieldref = $struct_fields{$stype}->{$fname};
		my($ftype, $fcount, $ftrans, $fvalue) = @$fieldref;
		my($fdata) = $this_struct{$fname}->[0];
		($fcount, $fcountset) = &struct_expression($struct_fields{$stype}, \%this_struct, $fcount, $parent_structs, $struct_start);
		@{$this_struct{$fname}} = ($fdata, $fcount, $fcount);
	}
	return  \%this_struct;
}

sub struct_write
{
	my($stype, $structref, $parent_structs, $struct_start, $struct_end, $array_last) = @_;

	unless(defined($parent_structs))
	{
		$parent_structs = [];
	}
	
	unless(defined($structref))
	{
		print STDERR "undefined structure\n";
		return;
	}
	$struct_start = 0 unless(defined($struct_start));

	for my $name_fields (@{$structs{$stype}})
	{
		my($fname, $fields) =  @$name_fields;

		my($ftype, $fcount, $ftrans, $fvalue, $foffset, $fptype, $fpname, $fpcount) = @$fields;
		$ftype = expand_struct_type($struct_fields{$stype}, $structref, $ftype);
		$ftrans = expand_struct_type($struct_fields{$stype}, $structref, $ftrans);
		print 'wrf ($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpcount = ' . "($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpcount)\n" if($debug);

		my($fdata, $fdatacount, $ftotalcount);
		if(defined($structref->{$fname}))
		{
			($fdata, $fdatacount, $ftotalcount) = @{$structref->{$fname}};
		}
# done in read
#		elsif($ftype ne "EVAL" and defined($fvalue))
#		{
#			($fvalue) = struct_expression($struct_fields{$stype}, $structref, $fvalue, $parent_structs);
#			#print STDERR "filled in value $stype $fname: $fvalue\n";
#			$fdata = &{$primative_fromstring{$ftype}}($fvalue, 1);
#			$fdatacount = $ftotalcount = 1;
#			@{$structref->{$fname}} = ($fdata, $fdatacount, $ftotalcount);
#		}

		if($ftype eq "EVAL")
		{
			($fdata) = struct_expression($struct_fields{$stype}, $structref, $fvalue, $parent_structs)
				if(defined($fvalue));
			if($fname eq "OFFSET_START")
			{
				$struct_start = tell(OUTFILE);
				next;
			}
			if($fname eq "ARRAY_LAST" or $fname eq "LAST")
			{
				$$array_last = $fdata;
#print "LAST $stype $ftype\n";
				next;
			}
			elsif($fname eq "BREAK")
			{
				$$array_last = $fdata;
				if($fdata) { last; }
				else { next; }
			}
			next;
		}


		# handle unread stype
		unless(defined($ftotalcount))
		{
			($ftotalcount, $fcount) = &struct_expression($struct_fields{$stype}, $structref, $fcount, $struct_start);
			#print "warning $ftype $fname  $fdatacount, $ftotalcount $fcount\n";
			#$ftotalcount = $fcount;
		}

		my($prevpos);

		if(defined($foffset))
		{
			($foffset) = &struct_expression($struct_fields{$stype}, $structref, $foffset, $struct_start);
			next unless($foffset);
			print "seek error: $!\n" unless(	
			seek(OUTFILE, $struct_start + $foffset, 0));
			print "seek to $struct_start + $foffset\n" if($debug);
		}
printf ("off: %d(%x) %d(%x) + %d\n", tell(OUTFILE), tell(OUTFILE), tell(OUTFILE) - $struct_start, tell(OUTFILE) - $struct_start, length($bitbufout)) if($debug);

		push(@$parent_structs, $structref);
		write_type(\*OUTFILE, $ftype, $fdata, $ftotalcount, $fname, $parent_structs, $struct_start, $struct_end, $array_last);
		pop(@$parent_structs);

		next unless( 
			defined($fptype) and
			defined($fpname) and
			defined($structref->{$fpname}) and
			ref $fdata eq "ARRAY" and
			scalar(@$fdata));

		
                my($fpdata, $fpdatacount, $fptotalcount) = @{$structref->{$fpname}};
		print "fp $structref $fpdata $fpdatacount $fptotalcount\n" if($debug);
		next unless(ref $fpdata eq "ARRAY");
		my(@fpdatasplit) = array_split($fpdatacount, @$fpdata);

		push(@$parent_structs, $structref);
		for (my $i = 0; $i < @$fdata; $i++)
		{
			my $offset = $fdata->[$i];
			my $data = $fpdatasplit[$i];
			print "warning zero offset in $ftype $fptype\n" unless($offset);
			my $prevpos = tell(OUTFILE);
			print "seek error: $!\n" unless(
			seek(OUTFILE, $struct_start + $offset, 0));
			#print "seekp to $struct_start + $offset\n";
			print STDERR "$fptype $fptotalcount\n" if($debug);
			write_type(\*OUTFILE, $fptype, $data, $fptotalcount, $fpname, $struct_start);
			seek(OUTFILE, $prevpos, 0);
		}
		pop(@$parent_structs);
	}
}

sub array_split
{
	my($count, @data) = @_;
	my(@out);
	while(@data)
	{
		my(@part) = splice(@data, 0, $count);
		push(@out, \@part);
	}
	return @out;
}

sub write_type
{
	my($fh, $stype, $data, $count, $name, $parent_stucts, $struct_start, $struct_end, $array_last) = @_;

	print "write_type $stype $count $name\n" if ($debug);

	if(defined($primative_toraw{$stype}))
	{

		my $refout = &{$primative_toraw{$stype}}($data, $count);
		print "$stype $name $count\n" if($count <0);

		if(defined($primative_sizebits{$stype}) && defined($count))
		{
			if(!defined($count))
			{
				if($primative_sizebits{$stype} == 1)
				{
					my $rem = 8 - length($bitbufout);
					$rem = 0 if($rem == 8);
					$count = $rem;
				}
			}

			write_bits($fh, $refout, $count * $primative_sizebits{$stype});
		}
		else
		{
			write_bits($fh, $refout, length($$refout) *8);
		}

		if($debug)
		{
			my $p = tell($fh);
			my $s = &{$primative_tostring{$stype}}($data, $count);
			print "write @ $p $stype $count s $s\n";
		}
	}
	elsif(defined($structs{$stype}))
	{
		#print "write stype $stype\n";
		write_structs(\*OUTFILE, $stype, $data, $count, $parent_stucts, $struct_start, $stuct_end, $array_last);
	}
	else
	{
		print STDERR "unknown stype $stype\n";
	}
}

# 
sub write_structs
{
	my($fh, $stype, $structs_ref, $fcount, $parent_structs, $struct_start, $struct_end, $array_last) = @_;

	undef $fcount if($fcount eq '');
	my $fcounthave = 0;

	print STDERR "negative count $fcount\n" if($fcount < 0);


	if(defined($structs_ref))
	{
		my @refs =
			( ref($structs_ref) eq "ARRAY" ) ?
			( @$structs_ref ) :
			( $structs_ref );
		for my $struct_ref (@refs)
		{
			struct_write($stype, $struct_ref, $parent_structs, $struct_start, $struct_end, $array_last);
			$fcounthave++;
		}
	}
	return unless(defined($fcount));

	my $fcountunset = $fcount - $fcounthave;

	print STDERR "too many $fcount ($fcountunset) $stype\n" if($fcountunset < 0);
	if($fcountunset >0)
	{
		#print "unset count $fcountunset in a $stype\n";
		#print "wt2 $stype $fcount $fcountunset\n";
		write_bits($fh, undef, struct_size($stype) *
			$fcountunset);
	}
}

sub data_has_value
{
	my($data) = @_;
	return 0 unless(defined($data));
	return 0 if(ref $data eq 'ARRAY' and @$data == 0);
	#print "ref " . ref $data . "$data\n";
	return 1;
}

sub get_primative_param_string
{
	my($stype, $structref) = @_;
	my(@value_sets);
        for my $name_fields (@{$structs{$stype}})
        {
		my($fname, $fields) =  @$name_fields;
		next unless(defined($structref->{$fname}));
		my($ftype, $fcount, $ftrans, $fvalue, $foffset, $fptype, $fpname, $fpsize) = @$fields;
	
		$ftype = expand_struct_type($struct_fields{$stype}, $structcref, $ftype);
		next unless(defined($primative_tostring{$ftype}));

		$ftrans = expand_struct_type($struct_fields{$stype}, $structref, $ftrans);
		my($fdata, $fdatacount) = @{$structref->{$fname}};
		my ($value) = &{$primative_tostring{$ftype}}($fdata, $fdatacount, $translations{$ftrans});
#x
#		if(defined($ftrans) and
#			defined($translations{$ftrans}) and
#			defined($translations{$ftrans}->{$value}))
#		{
#			$value = $translations{$ftrans}->{$value};
#		}

		push(@value_sets, "$fname=\"$value\""); 
	}
	return join(' ', @value_sets);
}
		
sub struct_write_xml
{
	my($stype, $name, $structref, $indent) = @_;
	my $tag_params = $minimal_xml ? get_primative_param_string($stype, $structref) : "";
	$tag_params = " " . $tag_params unless($tag_params eq '');

	$indent = "" unless(defined($indent));
	my $indent0 = $indent;

	unless(defined($structs{$stype}))
	{
		print STDERR "unknown struct: $stype\n";
		return;
	}

	return unless (%$structref);

	unless( $stype eq "MAIN")
	{
		print OUTFILE "$indent0<$name$tag_params" unless $stype eq "MAIN";
		$indent .= "\t";
	}


	my $count = 0;

	for my $name_fields (@{$structs{$stype}})
	{
		my($fname, $fields) =  @$name_fields;
		my($ftype, $fcount, $ftrans, $fvalue, $foffset, $fptype, $fpname, $fpsize) = @$fields;
		$ftype = expand_struct_type($struct_fields{$stype}, $structref, $ftype);
		$ftrans = expand_struct_type($struct_fields{$stype}, $structref, $ftrans);
		next if($ftype eq "OFFSET_START");
                next unless(defined($structref->{$fname}));
		my($fdata, $fdatacount) = @{$structref->{$fname}};
		next unless($fdatacount);
		next unless(data_has_value($fdata));
		print "xml out $fname, $ftype, $fcount\n" if($debug);
		print "fdata out value : ", fdata_value($fdata) , "\n" if($debug);

		if (!defined($primative_tostring{$ftype}) and $ftype ne "EVAL")
		{
			next unless(scalar(@$fdata) > 1 or scalar(@$fdata) == 1 and %{$fdata->[0]});
		}
		elsif($minimal_xml and (! defined($fptype)) and $stype ne "MAIN")
		{
			next;
		}

		#next if ($minimal_xml and (! defined($fptype)) and $stype ne "MAIN" and (defined($primative_tostring{$ftype}) or $ftype eq "EVAL"));

		print OUTFILE ">\n" unless($count or $stype eq "MAIN");

		$count++;
		   if(!defined($primative_tostring{$ftype}) and $ftype ne "EVAL")
		   {
			   for my $substructref (@{$fdata})
			   {
				   struct_write_xml($ftype, $fname, $substructref, $indent);
			   }
		   }
		elsif($stype eq "MAIN" || !$minimal_xml)
		{
			my $strout;
			if($ftype eq "EVAL")
			{
				$strout = $fdata;
			}
			else
			{
			if(0 && $debug)
			{
				my $p = tell(OUTFILE);
				my $r = &{$primative_toraw{$ftype}}($fdata, $fdatacount);
				$strout = unpack("H*", $$r);
			}
			else
			{ $strout = &{$primative_tostring{$ftype}}($fdata, $fdatacount, $translations{$ftrans}); }
			}
#x
#			if(defined($ftrans) and 
#			 defined($translations{$ftrans}) and
#			 defined($translations{$ftrans}->{$strout}))
#			{
#				$strout = $translations{$ftrans}->{$strout};
#			}
			print OUTFILE "$indent<$fname>$strout</$fname>\n";
		   }

                   next unless(defined($fptype));
		   my($fpdata, $fpdatacount) = @{$structref->{$fpname}};
 
		   if(defined($primative_tostring{$fptype}))
		   {
			   my $strout = &{$primative_tostring{$fptype}}($fpdata, $fpdatacount);
			   print OUTFILE "$indent<$fpname>$strout</$fpname>\n";
		   }
		   else
		   {
			   for my $substructref (@{$fpdata})
			   {
				   struct_write_xml($fptype, $fpname, $substructref, $indent);
			   }
		   }
	   }
	print OUTFILE $count ? "$indent0</$name>\n" : "/>\n" unless $stype eq "MAIN";
}

sub struct_size
{
	my($stype) = @_;
	my($size) = 0;
	for my $name_fields (@{$structs{$stype}})
	{
		my($fname, $fields) =  @$name_fields;
		my($ftype, $fcount,$ftrans, $fvalue, $foffset) = @$fields;
		next if($ftype eq "OFFSET_START");
		if($fcount =~ /[^\d*]/)
		{
			print "warn attempt to get size of dynamic($fcount)  stype $ftype $fname in $stype\n" if ($debug);
			return undef;
		}
		if(defined($foffset))
		{
			print "error: attempt to get size of irregular struct\n";
		}
		if(defined($structs{$ftype}))
		{
			my $ssize = struct_size($ftype);
			$size = defined($ssize) ? $size + $ssize : undef;
		}
		elsif(defined($primative_sizebits{$ftype}))
		{
			$size += $fcount * $primative_sizebits{$ftype};
		}
		else
		{
			print "warn no size info for '$ftype'\n" if($debug);
			$size = undef;
		}
	}
	return $size;
}

sub fdata_value
{
	my($fdata) = @_;

	return (ref($fdata) eq 'ARRAY') ? $fdata->[0] : $fdata;
}

sub fdata_equals
{
	my($fdata, $fvalue) = @_;

	return fdata_value($fdata) eq $fvalue;
}


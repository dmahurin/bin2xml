#!/usr/bin/perl
# bin2xml
# Tool to convert binary files of known formats to/from free
# format xml. The binary specification file allows for: primative
# types, structs, struct pointers and translations.
#
# -don mahurin

#use strict;

use POSIX;

my $bitbufin = '';
my $bitbufout = '';

my %translations;
my %reverse_translations;

my $debug = 0;


sub read_bits
{
	my($fh, $sizebits) = @_;

	my($buf) = '';
	my($readsizebits) = $sizebits - length($bitbufin);
	my($readsize) = POSIX::ceil($readsizebits / 8);
	read(INFILE, $buf, $readsize)
		if($readsizebits > 0);
	if($bitbufin ne '' or $readsizebits % 8)
	{
		$bitbufin .= unpack("B*", $buf);
		my $databits = substr ($bitbufin, 0, $sizebits, '');

		$buf =  pack('B*', $databits);
	}
	return $buf;
}

sub write_bits
{
	my( $fh, $bufref, $sizebits) = @_;

	# truncate or expand to fit
	my($datasize) = POSIX::ceil($sizebits / 8);
	unless(defined($bufref) and length($$bufref) == $datasize)
	{
		my $buf = pack("a$datasize", $$bufref);
		$bufref = \$buf;
	}
	if( $bitbufout ne '' or $sizebits % 8)
	{
		$bitbufout .= unpack("B$sizebits", $$bufref);
		$datasize = int(length($bitbufout) / 8);
		return unless($datasize);

		my($data) = pack('B*',
		substr($bitbufout, 0, $datasize * 8, ''));
		$bufref = \$data;
	}
	my $writelen = length($$bufref);
	print "error: invalid write datalen: $writelen != $datasize\n"
		unless($writelen == $datasize);
	print $fh $$bufref;
}

# splits a string up by spaces or as enclosed by quotes
sub split_strings
{
	my($in) = @_;
	my(@out);
	while($in ne '' && 
		(
		$in =~ m/^\'([^\']*)\'(\s+|$)/ or
		$in =~ m/^\"([^\"]*)\"(\s+|$)/ or
		$in =~ m/^(\S*)(\s+|$)/ ) )
	{
		push(@out, $1);
		$in = $';
	}
	return undef if($in ne "");
	return @out;
}

sub parse_translation
{
	my($lines) = @_;
	my(%translation, %reverse_translation);
	for my $line (split(/\s*\n\s*/ms, $lines))
	{
		my($from, $to) = split_strings($line);
		next if(! defined($from));
		next if($from eq "" and $to eq "");
		$translation{$from} = $to;
		$reverse_translation{$to} = $from;
	}
	return(\%translation, \%reverse_translation);
}

my $bit_count = 0;
#use strict;

my($fmtfile, $infile, $outfile) = @ARGV;

unless(defined($outfile))
{
	print "usage: $0 BFMT BINFILE XMLFILE\n";
	print "usage: $0 BFMT XMLFILE BINFILE\n";
	exit(0);
}
local %structs;
local %struct_fields;
my(%primative_sizebits);
my(%primative_fromraw);
my(%primative_toraw);
my(%primative_tostring);
my(%primative_fromstring);

open(FMT, $fmtfile);
local $/ = undef;
my($text) = <FMT>;
close(FMT);

$text =~ s:\/\/.*(?=$)::gm;
$text =~ s:#.*(?=$)::gm;

$primative_sizebits{"INT8"} =  $primative_sizebits{"CHAR"} = 
$primative_sizebits{"DATA"} =
$primative_sizebits{"SKIPBYTE"} = 8;

$primative_sizebits{"BITBITS"} =
$primative_sizebits{"HEXBITS"} =
$primative_sizebits{"INTBITS"} =
$primative_sizebits{"SKIPBITS"} = 1;

$primative_sizebits{"INT16"} = 16;
$primative_sizebits{"INT24"} = 24;
$primative_sizebits{"INT32"} = 32;

$primative_fromraw{"BITBITS"} =
$primative_fromraw{"HEXBITS"} =
$primative_fromraw{"CHAR"} =
$primative_fromraw{"UUDATA"} =
sub
{
   my($bufref, $len) = @_;
   return $bufref;
};


# store INTBITS as padded INT32's in memory
$primative_fromraw{"INTBITS"} =
sub
{
	my($bufref, $len) = @_;
	my($bits) = unpack("B$len", $$bufref);
	my($align) = 32 - ( $len % 32);
	$align = 0 if($align == 32);
	my($prebits) = '';
	while($align--) { $prebits .= '0'}

	my(@bufout) = unpack("N*", pack("B*", $prebits . $bits));
	return \@bufout;
};

$primative_fromraw{"DATA"} =
sub
{
	my($bufref) = @_;
	return undef if($$bufref =~ m:^\0*$:); #don't store zero data
	return $bufref;
};

$primative_fromraw{"SKIPBYTE"} = 
$primative_fromraw{"SKIPBITS"} = 
sub
{
   return undef;
};

$primative_toraw{"BITBITS"} = 
$primative_toraw{"HEXBITS"} = 
$primative_toraw{"CHAR"} =
$primative_toraw{"DATA"} =
$primative_toraw{"UUDATA"} =
sub
{
   my($bufref) = @_;
   return $bufref;
};

# store INTBITS as integers in memory.
$primative_toraw{"INTBITS"} = 
sub
{
	my($bufref, $len) = @_;
	my($bits) = unpack("B*", pack("N*", @$bufref));
	my($align) = 32 - ($len % 32);
	$align = 0 if($align == 32);
	my($buf) = pack("B*", substr($bits, $align));
	return \$buf;
};

$primative_toraw{"SKIPBITS"} = 
$primative_toraw{"SKIPBYTE"} = 
sub
{
	return undef;
};

$primative_fromraw{"INT32"} =
sub
{
   my($bufref) = @_;
   my(@bufout) = unpack('N*', $$bufref);
   return \@bufout;
};

$primative_fromraw{"INT8"} =
sub
{
   my($bufref) = @_;
   my(@bufout) = unpack('C*', $$bufref);
   return \@bufout;
};

$primative_toraw{"INT8"} =
sub
{
   my($bufref) = @_;
   my($bufout) = pack('C*', @$bufref);
   return \$bufout;
};



$primative_fromraw{"INT16"} =
sub
{
   my($bufref) = @_;
   my(@bufout) = unpack('n*', $$bufref);
   return \@bufout;
};

$primative_toraw{"INT16"} =
sub
{
   my($bufref) = @_;
   my($bufout) = pack('n*', @$bufref);
   return \$bufout;
};

# pad INT24 to INT32's
$primative_fromraw{"INT24"} =
sub
{
	my($bufref) = @_;
	my(@data) = unpack('C*', $$bufref);
	my(@bufout);
	while(@data)
	{
		my(@n) = splice(@data, 0, 3);
		unshift(@n, 0); # add high byte
		push(@bufout, unpack("N", pack("C4", @n)));
	}
	return \@bufout;
};
	
$primative_toraw{"INT24"} =
sub
{
	my($bufref) = @_;

	my(@data) = @$bufref;

	my(@bufout);
	while(@data)
	{
		my(@n) = unpack("C4", pack("N", shift(@data)));
		shift(@n); # remove high byte
		push(@bufout, @n);
	}
	
	my($buf) = pack('C*', @bufout);
	return \$buf;
};


$primative_toraw{"INT32"} =
sub
{
   my($bufref) = @_;
   my($bufout) = pack('N*', @$bufref);
   return \$bufout;
};

$primative_tostring{"DATA"} =
sub
{
   my($bufref) = @_;
   
   my $l = length($$bufref);
   return unpack("H*", $$bufref);
   
};

$primative_tostring{"UUDATA"} =
sub
{
   my($bufref) = @_;

   return unpack("u*", $$bufref);
   
};

$primative_tostring{"SKIPBYTE"} = 
$primative_tostring{"SKIPBITS"} = 
sub { return undef; };
$primative_fromstring{"SKIPBYTE"} = 
$primative_fromstring{"SKIPBITS"} = 
sub { return undef; };

$primative_tostring{"BITBITS"} =
sub
{
	my($bufref, $len) = @_;
	return unpack("B$len", $$bufref);
};

$primative_fromstring{"BITBITS"} =
sub
{
	my($instr, $len) = @_;
	my $buf = pack("B*", $instr);
	return \$buf;
};

$primative_tostring{"HEXBITS"} =
sub
{
	my($bufref, $len) = @_;

	my($bits) = unpack("B$len", $$bufref);
	my($align) = 8 - ( $len % 8);
	$align = 0 if($align == 8);
	my($prebits) = '';
	while($align--) { $prebits .= '0'}
	
	my $str = unpack("H*", pack("B*", $prebits . $bits));
	
	# strip off first 4bit nibble if needed
	$str = substr($str, 1) if(length($prebits) >= 4);
};

$primative_fromstring{"HEXBITS"} =
sub
{
	my($instr, $len) = @_;
	my $bits = unpack("B*", pack("H*", $instr));
	my($align) = 8 - ($len % 8);
	$align = 0 if($align == 8);
	$bits = substr($bits, $align);
	my($buf) = pack("B*", $bits);
	return \$buf;
};

$primative_fromstring{"DATA"} = 
sub
{
   my($instr) = @_;
   my($buf);

   $buf = pack("H*", $instr);
   return \$buf;
};

$primative_fromstring{"UUDATA"} = 
sub
{
   my($instr) = @_;
   my($buf);

   $buf = pack("u*", $instr);
   return \$buf;
};

$primative_tostring{"CHAR"} =
sub
{
	my($bufref, $len) = @_;
	my($buf) = unpack("Z$len", $$bufref);
	return $buf;
};

$primative_fromstring{"CHAR"} =
sub
{
	my($instr, $len) = @_;
	return \$instr if(length($instr) == $len);
	my($buf) = pack("Z$len", $instr);
	return \$buf;
};

$primative_tostring{"INT8"} =
$primative_tostring{"INT16"} = 
$primative_tostring{"INT24"} = 
$primative_tostring{"INT32"} =
$primative_tostring{"INTBITS"} =
sub
{
   my($bufref) = @_;
   return (join ",", @$bufref);
};

$primative_fromstring{"INT8"} =
$primative_fromstring{"INT16"} =
$primative_fromstring{"INT24"} =
$primative_fromstring{"INT32"} =
$primative_fromstring{"INTBITS"} =
sub
{
	my($instr) = @_;
	my @out = split(',', $instr);
	return \@out;
};

while(1)
{
if($text =~ m%^\s*([\w]+):\s*\n\s*([^:]+)\s*\n:\n%s )
{
	my($structname) = $1;
	my($fields) = $2;

	my $i = 1;
        for my $field (split(/\s*\n\s*/ms, $fields))
        {
		next if $field eq "";
		$field =~ m:^
			(\[([^\]]*)\]\s*)? # [$2]
			(([\w{}]+)(\s*\[([^\[\]]+)\])?\@)? # $4[$6]@
			([\w{}]+)(\s*\[([^\[\]]+)\])? # $7[$9]
			(\s+\<([\w{}]+)\>)? # <$11>
			(\s+((\w+)\@)?(\w+))? # 14@15
			:x;
		my($offset, $ptype, $pcount, $type, $count, $trans, $pname, $name) = ($2, $4, $6, $7, $9, $11, $14, $15);
		print '($offset, $ptype, $pcount, $type, $count, $trans, $pname, $name) = ($2, $4, $6, $7, $9, $11, $14, $15) = ' . "$offset, $ptype, $pcount, $type, $count, $trans, $pname, $name\n" if ($debug);
                $count = 1 unless(defined($count));
		$name = $type . $i unless(defined($name));
		if(defined($ptype))
		{
			$pcount = 1 unless(defined($pcount));
			my $fields = [ $type, $count, $trans, $offset, $ptype, $pname, $pcount ];
			push(@{$structs{$structname}}, [ $name, $fields ]);
			$struct_fields{$structname}->{$name} = $fields;
			# when reading xml, we need the ptypes as fields too
			$struct_fields{$structname}->{$pname} = [ $ptype, $pcount ];
		}
		else
		{
			my $fields = [ $type, $count, $trans, $offset ];
			push(@{$structs{$structname}}, [ $name, $fields ]);
			$struct_fields{$structname}->{$name} = $fields;
		}
		$i++;
	}
	$text = $'; #indentfix->';
}
elsif($text =~ m%^\s*([\w\d]+)=$([^=]+)^=$%ms )
{
	($translations{$1}, $reverse_translations{$1}) = parse_translation($2);
	$text = $';
}
else { last; }
}

for my $structname (keys %structs)
{
	print "struct $structname\n" if ($debug);
        for my $name_fields (@{$structs{$structname}})
	{
		my($name, $fields) = @$name_fields;
		my($type, $count) = @$fields;
		print "fields: type $type, name $name, size $count\n" if($debug);
	}
}


if($infile =~ m:\.xml$:)
{
print "xml to raw\n";
open(INFILE, $infile);
open(OUTFILE, ">$outfile");
my $mainref = struct_read_xml("MAIN");
#struct_write_xml("MAIN", $mainref); 
struct_write("MAIN", $mainref); 
close(INFILE);
close(OUTFILE);
}
elsif($outfile =~ m:\.xml$:)
{
print "raw to xml\n";
open(INFILE, $infile);
open(OUTFILE, ">$outfile");
my $mainref = struct_read("MAIN");
struct_write_xml("MAIN", $mainref); 
close(INFILE);
close(OUTFILE);
}
else
{
open(INFILE, $infile);
open(OUTFILE, ">$outfile");
my $mainref = struct_read("MAIN");
struct_write("MAIN", $mainref); 
close(INFILE);
close(OUTFILE);
   print "unknown conversion\n";
}

sub struct_read
{
	my($type, $struct_start) = @_;
	my(%this_struct);
	unless(defined($struct_start))
	{
		$struct_start = tell(INFILE);
	}
	
	for my $name_fields (@{$structs{$type}})
	{
		my($fname, $fields) = @$name_fields;
		my($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpcount) = @$fields;
		my($fdata);
		my($fcountset, $fpcountset);
print "read: $type: $ftype, $fname, fc = $fcount, $foffset\n" if($debug);

		$ftype = expand_struct_type(\%this_struct, $type, $ftype);
		$ftrans = expand_struct_type(\%this_struct, $type, $ftrans);
			
		if($ftype eq "OFFSET_START")
		{
			$struct_start = tell(INFILE);
			next;
		}

		my($pos);
		
		#print "$fcount\n";
		($fcount, $fcountset) = &struct_expression(\%this_struct, $fcount);
		next unless($fcount);
		#print "count: $fcount, $fcountset\n";
		$fcountset = $fcount unless(defined($fcountset) and
			$fcountset <= $fcount);
		#print "pcount in: $fpcount\n";

		($fpcount, $fpcountset) = &struct_expression(\%this_struct, $fpcount);
		#print "pcount: $fpcount\n";
		$fpcountset = $fpcount unless(defined($fpcountset) 
			and $fpcountset <= $fpcount);
#print "fff: $type: $ftype, $fname, fsc = $fcountset, fc = $fcount, $foffset\n";
		if(defined($foffset))
		{
			$foffset = &struct_expression(\%this_struct, $foffset, $struct_start);
			next unless($foffset);
			$pos = tell(INFILE);

			print "seek error: $!\n"
			unless(seek(INFILE, $struct_start+ $foffset,0));
		}
#printf ("off: %x %x + %d\n", tell(INFILE), tell(INFILE) - $struct_start, length($bitbufin));
		if(defined($primative_sizebits{$ftype}))
		{
			my $buf = read_bits(\*INFILE, $fcount * 
				$primative_sizebits{$ftype});

			$fdata = &{$primative_fromraw{$ftype}}(\$buf, $fcountset);
		}
		elsif(defined($structs{$ftype}))
		{
			#print "struct in: $ftype ($fcountset of $fcount)\n";
			my $i;
			for ($i = 0 ; $i < $fcountset; $i++)
			{
				push(@{$fdata} ,
				struct_read($ftype, $struct_start));
			}
			my $countunset = $fcount - $fcountset;
			read_bits(\*INFILE, $countunset *
                                struct_size($ftype))
					if($countunset);
		}
		else
		{
			print STDERR "unknown type: $ftype\n";
		}

		#print "set struct $fname ($fcountset)\n";
		@{$this_struct{$fname}} = ($fdata, $fcountset, $fcount)
			if(defined($fdata));
		my $fpdata;
		
		# read in structs pointed to
		if(defined($fptype) and ref $fdata eq "ARRAY")
		{
			#print "POINTER struct in: $fptype\n";
			my $prevpos = tell(INFILE);
			#print "POINTER read $fcount by $fpcount\n";
			for (my $i = 0 ; $i < $fcount; $i++)
			{
				next unless($fdata->[$i]);
				my $newpos = $struct_start + $fdata->[$i];
				#print "seek from $prevpos to $newpos\n";
				print "seek error: $!\n"
				unless(seek(INFILE, $newpos, 0));
				for (my $pi = 0 ; $pi < $fpcount; $pi++)
				{
					push(@$fpdata ,
						struct_read($fptype, $struct_start));
				}
				@{$this_struct{$fpname}} = ($fpdata, $fpcountset, $fpcount)
				if(defined($fpdata));
			}
			seek(INFILE, $prevpos, 0);
		}
#		seek(INFILE, $pos, 0 ) if(defined($pos));
	}
	return \%this_struct;
}

sub expand_struct_type
{
	my($structref, $type, $ftype) = @_;

	while($ftype =~ m/{([^{}]+)}/)
	{
		my $othername = $1;
		my ($before, $after) = ($`,$');
		$othername = "DEFAULT" unless(defined($structref->{$othername}));
		last unless(defined($structref->{$othername}));
		my $otherfields = $struct_fields{$type}->{$othername};
		last unless(defined($otherfields));
		my($othertype, $othercount, $othertrans) = @$otherfields;
		my ($data, $datacount) = @{$structref->{$othername}};
		last unless(defined($data));
		last unless(defined($primative_tostring{$othertype}));
		my $s = &{$primative_tostring{$othertype}}($data, $othercount);
		$s = $translations{$othertrans}->{$s}
		if(defined($othertrans) and defined($translations{$othertrans}) and defined($translations{$othertrans}->{$s}));
		$ftype = $before . $s . $after;
	}
	return $ftype;
}

sub struct_expression
{
	my($this_struct, $buf, $struct_start) = @_;
	return $buf unless($buf =~ /\D/);
	my($buf2) = '';
	while($buf =~ m:([A-Za-z]\w+):)
	{
		$buf = $'; #';#<-indent fix
		$buf2 .= $`;
		if($1 eq "struct_start")
		{
			$buf2 .= $struct_start;
		}
		elsif(ref($this_struct->{$1}->[0]) eq 'ARRAY')
		{
			$buf2 .= $this_struct->{$1}->[0]->[0];
		}
		else
		{
			#$buf2 .= $this_struct->{$1}->[0];
			$buf2 .= ${$this_struct->{$1}->[0]};
		}
	}
	$buf2 .= $buf;
	return eval($buf2);
}

sub struct_read_xml
{
	my($type, $name) = @_;
	
	my(%this_struct);
	
	local $/ = '>';
	while(defined(my $tag = <INFILE>))
	{
		last unless ($tag =~ m:\S:m);
		unless($tag =~ m:^\s*\<([^\>]+)\>$:m)
		{
			print "did not get expected tag in $name\n";
			last;
		}
		my $fname = $1;
		last if(defined($name) and $fname eq "/$name");
		if(defined($struct_fields{$type}->{$fname}))
		{
			my $fieldref = $struct_fields{$type}->{$fname};
			my($ftype, $fcount, $ftrans) = @$fieldref;
			my($fdata);
			# add sequential structure
			$fdata = $this_struct{$fname}->[0]
				if(defined($this_struct{$fname}));
			my($fcountset, $fpcountset);

			$ftype = expand_struct_type(\%this_struct, $type, $ftype);
			$ftrans = expand_struct_type(\%this_struct, $type, $ftrans);
			($fcount, $fcountset) = &struct_expression(\%this_struct, $fcount, $struct_start);
			next unless($fcount);
			$fcountset = $fcount unless(defined($fcountset) and
				$fcountset <= $fcount);
			#print "pcount in: $fpcount\n";
			($fpcount, $fpcountset) = &struct_expression(\%this_struct, $fpcount, $struct_start);
			$fpcountset = $fpcount unless(defined($fpcountset) 
				and $fpcountset <= $fpcount);
			
			if(defined($primative_fromstring{$ftype}))
			{
				local $/ = "</$fname>";
				my $data = <INFILE>;
				unless(defined($data))
				{
					print STDERR "incomplete field: $fname\n";
					last;
				}
				chomp $data;
				if(defined($ftrans) and defined($reverse_translations{$ftrans}) and defined $reverse_translations{$ftrans}->{$data})
				{
					$data = $reverse_translations{$ftrans}->{$data};
				}
				
				$fdata =
				&{$primative_fromstring{$ftype}}($data, $fcountset);
				
			}
			else
			{
				push(@$fdata, struct_read_xml($ftype, $fname));
			}
			@{$this_struct{$fname}} = ($fdata, $fcountset, $fcount);
			my $rr = \%this_struct;
			print "xmlin $rr $ftype $fdata $fname $fcount $fcountset\n" if ($debug);
		}
		else
		{
			print "no such field: $fname in $type\n";
		}
	}
	return  \%this_struct;
}

sub bufref_resize
{
   my($bufref, $size) = @_;
  
   return $bufref unless(ref ($bufref) eq "SCALAR");

   my($slen) = length($$bufref);

   return $bufref if($slen == $size);

   if($slen > $size)
   {
     $$bufref = substr($$bufref, 0, $size); 
   }
   else
   {
  for(; $slen < $size; $slen++)
  {
     $$bufref .= '\0';
  }
  }
  return $bufref;
}


sub struct_write
{
	my($type, $structref, $struct_start) = @_;
	
	unless(defined($structref))
	{
		print STDERR "undefined structure\n";
		return;
	}
	$struct_start = 0 unless(defined($struct_start));

	for my $name_fields (@{$structs{$type}})
	{
		my($fname, $fields) =  @$name_fields;

		my($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpcount) = @$fields;
		$ftype = expand_struct_type($structref, $type, $ftype);
		$ftrans = expand_struct_type($structref, $type, $ftrans);
		print 'wrf ($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpcount = ' . "($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpcount)\n" if($debug);

		if($ftype eq "OFFSET_START")
		{
			$struct_start = tell(OUTFILE);
			next;
		}

		my($fdata, $fdatacount, $ftotalcount) = 
			@{$structref->{$fname}};

		# handle unread type
		unless(defined($ftotalcount))
		{
			($ftotalcount, $fcount) = &struct_expression(\%this_struct, $fcount, $struct_start);
			#print "warning $ftype $fname  $fdatacount, $ftotalcount $fcount\n";
			#$ftotalcount = $fcount;
		}

		my($prevpos);

		if(defined($foffset))
		{
			$foffset = &struct_expression($structref, $foffset, $struct_start);
			next unless($foffset);
			print "seek error: $!\n" unless(	
			seek(OUTFILE, $struct_start + $foffset, 0));
			print "seek to $struct_start + $foffset\n" if($debug);
		}
		print "write $fname $type $ftotalcount\n" if($debug);
printf ("off: %d(%x) %d(%x) + %d\n", tell(OUTFILE), tell(OUTFILE), tell(OUTFILE) - $struct_start, tell(OUTFILE) - $struct_start, length($bitbufout)) if($debug);

		write_type(\*OUTFILE, $ftype, $fdata, $ftotalcount, $struct_start);
		next unless( 
			defined($fptype) and
			defined($fpname) and
			defined($structref->{$fpname}) and
			ref $fdata eq "ARRAY" and
			@$fdata);

		
                my($fpdata, $fpdatacount, $fptotalcount) = @{$structref->{$fpname}};
		print "fp $structref $fpdata $fpdatacount $fptotalcount\n" if($debug);
		next unless(ref $fpdata eq "ARRAY");

		for my $offset (@$fdata)
		{
			#print "here $offset\n";
			print "warning zero offset in $ftype $fptype\n" unless($offset);
			my $prevpos = tell(OUTFILE);
			print "seek error: $!\n" unless(
			seek(OUTFILE, $struct_start + $offset, 0));
			#print "seekp to $struct_start + $offset\n";
			write_type(\*OUTFILE, $fptype, $fpdata, $fptotalcount, $struct_start);
			seek(OUTFILE, $prevpos, 0);
		}
	}
}

sub write_type
{
	my($fh, $type, $data, $count, $struct_start) = @_;

	if(defined($primative_toraw{$type}))
	{
		my $refout = &{$primative_toraw{$type}}($data, $count);
		my $strout = &{$primative_tostring{$type}}($data, $count);
		#print "wrt: $strout $type $count\n";
		
		write_bits($fh, $refout, $count * $primative_sizebits{$type});
	}
	elsif(defined($structs{$type}))
	{
		#print "write type $type\n";
		write_structs(\*OUTFILE, $type, $data, $count, $struct_start);
	}
	else
	{
		print "unknown type $type\n";
	}
}

# 
sub write_structs
{
	my($fh, $type, $structs_ref, $fcount, $struct_start) = @_;
	my $fcountunset = $fcount;

	if(defined($structs_ref))
	{
		for my $struct_ref (@$structs_ref)
		{
			struct_write($type, $struct_ref, $struct_start);
			$fcountunset--;
		}
	}
	if($fcountunset)
	{
		#print "unset count $fcountunset in a $type\n";
		#print "wt2 $count\n";
		write_bits($fh, undef, struct_size($type) *
			$fcountunset);
	}
}
	

sub struct_write_xml1
{
   my($type, $name, $dataref, $indent) = @_;
   $indent = "" unless(defined($indent));
   unless(defined($dataref)) 
   {
	print STDERR "undefined structure $type $name\n";
	return;
   }
   if(defined($primative_tostring{$type}))
   {
      my $strout = &{$primative_tostring{$type}}($dataref);
      print OUTFILE "$indent<$name>$strout</$name>\n";
   }
   elsif(defined($structs{$type}))
   {
      for my $structref (@$dataref)
      {
        for my $field (@{$structs{$type}})
	{
		my($ftype, $fname, $fcount) = @$field;
        	print OUTFILE "$indent<$fname>\n";
		struct_write_xml($ftype, $fname, $structref->{$fname}, $indent . "\t");
      		print OUTFILE "$indent</$fname>\n";
	}
      }
   }
}
		
sub struct_write_xml
{
	my($type, $structref, $indent) = @_;
	$indent = "" unless(defined($indent));

	unless(defined($structs{$type}))
	{
		print "unknown struct: $type\n";
		return;
	}
	for my $name_fields (@{$structs{$type}})
	{
		my($fname, $fields) =  @$name_fields;
		my($ftype, $fcount, $ftrans, $foffset, $fptype, $fpname, $fpsize) = @$fields;
		$ftype = expand_struct_type($structref, $type, $ftype);
		$ftrans = expand_struct_type($structref, $type, $ftrans);
		next if($ftype eq "OFFSET_START");
                   next unless(defined($structref->{$fname}));
		my($fdata, $fdatacount) = @{$structref->{$fname}};
#print "$fname, $ftype, $fcount\n";
		   if(defined($primative_tostring{$ftype}))
		   {
			   my $strout = &{$primative_tostring{$ftype}}($fdata, $fdatacount);
			if(defined($ftrans) and 
			 defined($translations{$ftrans}) and
			 defined($translations{$ftrans}->{$strout}))
			{
				$strout = $translations{$ftrans}->{$strout};
			}
			print OUTFILE "$indent<$fname>$strout</$fname>\n";
		   }
		   else
		   {
			   for my $substructref (@{$fdata})
			   {
				   print OUTFILE "$indent<$fname>\n";
				   struct_write_xml($ftype, $substructref, $indent . "\t");
				   print OUTFILE "$indent</$fname>\n";
			   }
		   }
                   next unless(defined($fptype));
		   my($fpdata, $fpdatacount) = @{$structref->{$fpname}};
 
		   if(defined($primative_tostring{$fptype}))
		   {
			   my $strout = &{$primative_tostring{$fptype}}($fpdata, $fpdatasize);
			   print OUTFILE "$indent<$fpname>$strout</$fpname>\n";
		   }
		   else
		   {
			   for my $substructref (@{$fpdata})
			   {
				   print OUTFILE "$indent<$fpname>\n";
				   struct_write_xml($fptype, $substructref, $indent . "\t");
				   print OUTFILE "$indent</$fpname>\n";
			   }
		   }
	   }
}

sub struct_size
{
	my($type) = @_;
	my($size) = 0;
	for my $name_fields (@{$structs{$type}})
	{
		my($fname, $fields) =  @$name_fields;
		my($ftype, $fcount) = @$fields;
		next if($ftype eq "OFFSET_START");
		if($fcount =~ /[^\d]/)
		{
			print "error attempt to get size of dynamic($fcount)  type $ftype $fname in $type\n";
		}
		if(defined($foffset))
		{
			print "error: attempt to get size of irregular struct\n";
		}
		if(defined($structs{$ftype}))
		{
			$size += $fcount * struct_size($ftype);
		}
		elsif(defined($primative_sizebits{$ftype}))
		{
			$size += $fcount * $primative_sizebits{$ftype};
		}
		else
		{
			print "error no size info for '$ftype'\n";
		}
	}
	return $size;
}

